---
title: Data analysis code, Meta-Analyses in tDCS - Motor Learning Research 
author: Taym Alsalti
output:
  html_document:
    number_sections: true
    toc: true
    toc_depth: 3
    toc_float: true
---

**Load packages and dataset**
```{r setup, echo = FALSE}
knitr::opts_chunk$set(
	message = FALSE,
	warning = FALSE,
	include = TRUE
)
# options(scipen = 999, digits = 2)
```

```{css, echo = FALSE}
# Automatically number chunks
body {
  counter-reset: counter-rchunks;
}

div.main-container {
  padding-left: 4em;
}

pre.r {
  counter-increment: counter-rchunks;
  position: relative;
  overflow: visible;
}

pre.r::before {
  content: '[' counter(counter-rchunks) ']:';
  display: inline-block;
  position: absolute;
  left: -4em;
  color: rgb(48, 63, 159);
}
```

```{r}
library("readxl") 
library("writexl")
library("tidyverse")
library("metafor")
df <- read_excel("data_thesis/Data_sheet_ps_ma1.xlsx")
```

If you want to run the code outside of the project folder and without the renv.lock file (from the [`renv`](https://rstudio.github.io/renv/articles/renv.html) package), loading the packages using the package [`groundhog`](https://groundhogr.com/) would ensure the code's long term reproducibility:
```{r}
# install.packages("groundhog")
# library("groundhog")
# pkgs <- c("readxl","writexl", "tidyverse", "metafor")
# date = "2021-08-27"
# groundhog.library(pkgs, date)
```


# Meta-analysis 1

## Reproducibility 
Note that most of the code in this section was adapted from [Maassen et al. (2020)](https://doi.org/10.1371/journal.pone.0233107)'s data analysis code, available [here](https://github.com/emaassen/paper-effectsizes/tree/master/code).

### Data wrangling - before double checking data extraction
#### Add a column specifying availablity of Ms and SDs
This facilitates automating the process of using the SMDs as reported in the meta-analysis in the case of primary studies for which it was impossible to reproduce the primary effect sizes due to lack of necessary data. 
```{r}
df <- df %>% 
  mutate(data_available = if_else(is.na(mc_ps.2), "no", "yes"))
```
In the case of this meta-analysis, all primary studies (PS) reported all Ms and SDs for the second time point if they reported one of them, which is why the new column is based on the mean of the control group at the second time point as an example. Will change this code if it turns out not to be the case in a future meta-analysis. 

#### Convert standard errors extracted from PS 8 to standard deviations
```{r}
# remove asterisks highlighting SEs
df[] <- lapply(df, gsub, pattern = '*', replacement = '', fixed = TRUE)
df <- df %>% mutate_at(vars(starts_with('sd')), as.numeric)
# multiply SEs by the square of the sample size (10 in both groups in PS 8)
df[11, "sdc_ps.1"] <- df[11, "sdc_ps.1"] * sqrt(10)
df[11, "sdc_ps.2"] <- df[11, "sdc_ps.2"] * sqrt(10)
df[11, "sdt_ps.1"] <- df[11, "sdt_ps.1"] * sqrt(10)
df[11, "sdt_ps.2"] <- df[11, "sdt_ps.2"] * sqrt(10)
```

### Functions for reproducing primary SMDs

#### Cohen's *d* for a between-groups comparison
This formula is very commonly used and can be found in dozens of text books, e.g., [Hedges and Olkin (1985, p. 78-79)](https://www.sciencedirect.com/book/9780080570655/statistical-methods-for-meta-analysis):
$$d={\frac {{\bar {x}}_{1}-{\bar {x}}_{2}}{s}}$$

$$s={\sqrt {\frac {(n_{1}-1)s_{1}^{2}+(n_{2}-1)s_{2}^{2}}{n_{1}+n_{2}-2}}}$$

Where ${\bar {x}}_{1}$ is the mean of the treatment group, ${\bar {x}}_{2}$ is the mean of the control group, $s$ is the pooled standard deviation, $n_{1}$ and $n_{2}$ are the sample sizes of the treatment and control groups, respectively, and $s_{1}$ and $s_{2}$ are the standard deviations of the treatment and control groups, respectively.


```{r}
cd_between <- function(x) {
  
  cohensd <- c()  
  
  for (k in 1:nrow(x)) {
    
    nc <- as.numeric(x$nc_ps)[k]
    nt <- as.numeric(x$nt_ps)[k]
    
    mc <-  as.numeric(x$mc_ps.2)[k]
    mt <-  as.numeric(x$mt_ps.2)[k]
    sdc <- as.numeric(x$sdc_ps.2)[k]
    sdt <- as.numeric(x$sdt_ps.2)[k]
    
    
    if (df$data_available[k] == "yes") {
      d <- ((mt - mc) / sqrt((((nc - 1) * (sdc^2)) + ((nt - 1) * (sdt^2))) / (nc + nt - 2)))
    } else {
      d <- as.numeric(df$smd_ma)[k]
    }    
    

    cohensd[k] <- d
    
  }
  return(cohensd)
}
```


#### Hedges' *g* for a between-groups comparison
Hedges' *g* is a small sample correction of Cohen's *d*, one way to compute it can be found in [Hedges and Olkin (1985, p. 81)](https://www.sciencedirect.com/book/9780080570655/statistical-methods-for-meta-analysis):
$$d={\frac {{\bar {x}}_{1}-{\bar {x}}_{2}}{s}}={\frac {\mu_{1}-\mu_{2}}{s}}$$

$$s={\sqrt {\frac {(n_{1}-1)s_{1}^{2}+(n_{2}-1)s_{2}^{2}}{n_{1}+n_{2}-2}}}$$

$$J={1-{\frac {3}{4N-9}}}$$

$$g=J \times d$$
Where $N = n_{1}+n_{2}$

```{r}
hg_between <- function(x) {
  
  hedgesg <- c()  
  
  for (k in 1:nrow(x)) {
    
    nc <- as.numeric(x$nc_ps)[k]
    nt <- as.numeric(x$nt_ps)[k]
    n <- nc + nt
    
    mc <-  as.numeric(x$mc_ps.2)[k]
    mt <-  as.numeric(x$mt_ps.2)[k]
    sdc <- as.numeric(x$sdc_ps.2)[k]
    sdt <- as.numeric(x$sdt_ps.2)[k]
    
    d <- (mt - mc) / sqrt((((nc - 1) * (sdc^2)) + ((nt - 1) * (sdt^2))) / (nc + nt - 2))
    # the f-else function was added to the Cohen's d function later. no need for it here since 
    # this meta-analysis used Cohen's ds, as demonstrated below
    
    # transform to hedges g
    J <- 1 - (3 / ((4 * n) - 9))  
    hedgesg[k] <- J * d
  }
  return(hedgesg)
}
```

### Reproduce primary SMDs
17 primary studies were included in MA1, based on which 21 comparisons were made and thus 21 SMDs calculated. Two comparisons were made based on studies 5, 6, 7 and 14, which had three groups: anodal, cathodal, and sham tDCS in contrast to the other studies which either had one type of tDCS or combined both types into one group. Hence, effect sizes/comparison ids 5 & 6, 7 & 8, 9 & 10, and 17 & 18 are based on identical control/sham groups.
```{r}
df$smd_r_d <- cd_between(df)
df$smd_r_g <- hg_between(df)
# put relevant columns next to each other to facilitate inspection
df <- df %>% relocate(data_available, .before = smd_r_d)
df <- df %>% relocate(smd_ma, .after = smd_r_g)
df <- df %>% relocate(24:27, .after = author)
```
Enough data were available to reproduce 8 out of the 21 effect sizes: comparison ids 4,5,6, 11, 14, 16, 17, and 18. Since the calculated Cohen's ds are almost identical to the SMDs reported in the MA, these will be used for computing the pooled SMD. Before double checking correct data extraction, 4 out of the 8 reproduced primary SMDs were equal to the reported ones after rounding to the second decimal place. For comparisons 11, 16, 17, and 18, the reproduced SMD did not equal the reported one. Data extraction for these comparisons was double checked:

* For comparison 11, the reproduced SMD was the negative of the reported one, indicating the meta-analysts reversed the sign as a reduction on the specific scale used in that study means improvement (SMD No. 11 was made positive in code chunk No. 9 below). Thus, this primary SMD can be seen as reproducible, which brings the number of reproducible SMDs to 5.

* For comparison 16, it turns out the means and SDs of changes were extracted, not the raw means and SDs, which were not reported in the PS. These values removed in chunk 10. Thus, the number of comparisons for which enough data is available is down to 7.

* For comparisons 17 and 18, both from PS 14, I could not find any errors in my data collection. However, since A. the meta-analysis specified "FMA" as the outcome measure used to compute the primary SMD and B. PS 14 reported values on two outcomes "FMA-total" and "UL-FMA", I tried reproducing the reported primary SMDs using the "FMA-total" values after having used the "UL-FMA" with the original data extraction. Regardless of the fact that neither sets of values reproduced the original SMDs (see code chunk No. 11), the UL-FMA values are more likely to be the ones used the by meta-analysts as the UL-FMA has the same scale as FMA-outcome measures from other primary studies included in the meta-analysis, which is why I will use these to compute the pooled SD.

In sum, there were enough data in the primary studies to attempt to reproduce 7 out of the 21 SMDs reported in MA1. Out of these 7 SMDs, 5 could be  reproduced using Cohen's *d*s. 

### Data wrangling - after double checking data extraction

#### Remove the Hedges' *g*s column
```{r}
df <- select(df, -"smd_r_g")
```

#### Convert SMD 11 to positive
```{r}
# Convert the reproduced SMDs to numerics
df$smd_r_d <- as.numeric(df$smd_r_d)

# Make SMD 11 positive
df[11, "smd_r_d"] <- -df[11, "smd_r_d"]
```

#### Remove the erroneous means and SDs extracted for SMD 16
```{r}
df[16, 18:21] <- NA
# change availability of data to "no" 
df[16, "data_available"] <- "no"

# replace the reproduced SMD with the SMD reported in the MA
df[16, "smd_r_d"] <-  as.numeric(df[16, "smd_ma"])
```

#### Reproduce SMDs 17 and 18 using the alternative "FMA-total" means and SDs
```{r}
nc_ps <- c(7, 7) 
nt_ps <- c(7, 7)
mc_ps.2 <- c(123.1, 123.1) # "FMA-total" values
mt_ps.2 <- c(124.7, 126.7) # "FMA-total" values
sdc_ps.2 <- c(7.47, 7.47) # "FMA-total" values
sdt_ps.2 <- c(6.94, 6.18) # "FMA-total" values
smd_ma <- c(0.94, 0.24) # SMDs reported in the meta-analysis for comparison
ps_14b <- data.frame(nc_ps, nt_ps, mc_ps.2, mt_ps.2, sdc_ps.2, sdt_ps.2, smd_ma)
ps_14b$alternative_smd <- cd_between(ps_14b) # "alternative" as in using alternative Ms and SDs to the originally reproduced SMDs above
print(ps_14b)
```

#### Round the reproduced SMDs to match reported ones
```{r}
#df$smd_r_d <- round(df$smd_r_d,digits = 2)
```

### Functions for reproducing within-study variances
#### Compute variance of Cohen's *d* for a between-groups comparison
To compute the pooled SMD, the within-study variance for each study, $\hat\sigma_i$, must be determined. The formula used here can be found in [Hedges and Olkin (1985, p. 86)](https://www.sciencedirect.com/book/9780080570655/statistical-methods-for-meta-analysis):

$$\hat\sigma_i={\frac {n_{1}+n_{2}}{n_{1}n_{2}}}+{\frac {d^2}{2(n_{1}+n_{2})}}$$

```{r}
vd_between <- function(x) {
  
  vd <- c()  
  
  for (k in 1:nrow(x)) {
    
    nc <- as.numeric(x$nc_ps)[k]
    nt <- as.numeric(x$nt_ps)[k]
    
    d <- as.numeric(df$smd_r_d)[k]
    
    v <- ((nc + nt) / (nc*nt)) + (d^2 / (2 * (nc + nt)))
      
    vd[k] <- v
    
  }
  return(vd)
}
```

#### Compute variance of Cohen's *d* for a within-group comparison

### Reproduce the pooled SMD
#### Compute variances of primary SMDs
```{r}
df$vd <- vd_between(df)
```
#### Confirm that the $\hat\sigma_i$s can be reproduced by already available software
```{r}
#library("MAd")

# compute ds and corresponding within study variances
#df <- compute_ds(as.numeric(nt_ps), as.numeric(mt_ps.2), as.numeric(sdt_ps.2), as.numeric(nc_ps), as.numeric(mc_ps.2), as.numeric(sdc_ps.2), df, denom = "pooled.sd")
# note that the ds are reproduced here too

# relocate to facilitate inspection
#df <- df %>% relocate(c(d, vd, var.d), .after = smd_ma)
```

At this point (07.09.21) I was reminded that, like in the case of the Cohen's *d*s themselves, the formula for computing the corresponding within-study variance wouldn't work for studies that had no control groups (cross-over trials). I contacted the authors of MA 1 on the 08.09.21 and received a reply that they used CMA to run the meta-analysis. As of 09.09.21, I'm waiting for further information.

** Load the dataset containing the meta-analysis level data**
```{r}
#DF <- read_excel("data_thesis/Data_sheet_ma_ma1.xlsx")
```
#### Set the type of the SMD for MA 1 to be "d"
```{r}
#DF[1, "psmd_type"] <- "d"
```




