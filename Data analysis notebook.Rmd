---
title: Data analysis notebook (messy but complete version), Meta-Analyses in tDCS - Motor Learning Research 
output:
  html_document:
    number_sections: true
    toc: true
    toc_depth: 3
    toc_float: true
---

**Load packages and dataset**
```{r setup, echo = FALSE}
knitr::opts_chunk$set(
	message = FALSE,
	warning = FALSE,
	include = TRUE
)
# options(scipen = 999, digits = 2)
```

```{css, echo = FALSE}
body {
  counter-reset: counter-rchunks;
}

div.main-container {
  padding-left: 3.5em;
}

pre.r {
  counter-increment: counter-rchunks;
  position: relative;
  overflow: visible;
}

pre.r::before {
  content: '[' counter(counter-rchunks) ']:';
  display: inline-block;
  position: absolute;
  left: -3.5em;
  color: rgb(48, 63, 159);
}

/* Whole document: */
body{
  font-family: Calibri;
  font-size: 11pt;
}
/* Headers */
h1{
  font-size: 18pt;
  text-align: center;
  font-weight: bold
}
h2{
  font-size: 16.5pt;
  text-indent: 2em
}
h3{
  font-size: 14pt;
  text-indent: 4em
}
h4{
  font-size: 12.5pt;
  text-indent: 6em
}
```


```{r}
library("readxl") 
library("tidyverse")
library("metafor")
library("MAd")
library("meta")
library("dmetar") # not available on CRAN as of September 2021, pulled from GitHub
df <- read_excel("data_thesis/Data_sheet_ps_ma1.xlsx")
```

If you want to run the code outside of the project folder and without the renv.lock file (from the [`renv`](https://rstudio.github.io/renv/articles/renv.html) package), loading the packages using the package [`groundhog`](https://groundhogr.com/) would ensure the code's long term reproducibility:
```{r}
# install.packages("groundhog")
# library(groundhog)
# pkgs <- c("readxl", "tidyverse", "metafor", "MAd", "meta")
# date = "2021-11-19"
# groundhog.library(pkgs, date)
```


# Meta-analysis 1

## Reproducibility 
Note that a large portion of the code in the reproducibility section was adapted from [Maassen et al. (2020)](https://doi.org/10.1371/journal.pone.0233107)'s data analysis code, available [here](https://github.com/emaassen/paper-effectsizes/tree/master/code).

### Data wrangling - before double checking data extraction
#### Add a column specifying availablity of Ms and SDs
This facilitates automating the process of using the SMDs as reported in the meta-analysis in the case of primary studies for which it was impossible to reproduce the primary effect sizes due to lack of necessary data. 
```{r}
df <- df %>% 
  mutate(data_available = if_else(is.na(mc_ps.2), "no", "yes"))
```
In the case of this meta-analysis, all primary studies (PS) reported all Ms and SDs for the second time point if they reported one of them, which is why the new column is based on the mean of the control group at the second time point as an example. Will change this code if it turns out not to be the case in a future meta-analysis. 

#### Convert standard errors extracted from PS 8 to standard deviations
```{r}
# remove asterisks highlighting SEs
df[] <- lapply(df, gsub, pattern = '*', replacement = '', fixed = TRUE)
# make sds numeric
df <- df %>% mutate_at(vars(starts_with('sd')), as.numeric)
# multiply SEs by the square of the sample size (10 in both groups in PS 8)
df[11, "sdc_ps.1"] <- df[11, "sdc_ps.1"] * sqrt(10)
df[11, "sdc_ps.2"] <- df[11, "sdc_ps.2"] * sqrt(10)
df[11, "sdt_ps.1"] <- df[11, "sdt_ps.1"] * sqrt(10)
df[11, "sdt_ps.2"] <- df[11, "sdt_ps.2"] * sqrt(10)
```

### Functions for reproducing primary SMDs

#### Cohen's $d$ for a between-groups comparison
This formula is very commonly used and can be found in dozens of text books, e.g., [Hedges and Olkin (1985, p. 78-79)](https://www.sciencedirect.com/book/9780080570655/statistical-methods-for-meta-analysis):
$$d={\frac {{\bar {x}}_{1}-{\bar {x}}_{2}}{s}}$$

$$s={\sqrt {\frac {(n_{1}-1)s_{1}^{2}+(n_{2}-1)s_{2}^{2}}{n_{1}+n_{2}-2}}}$$

Where ${\bar {x}}_{1}$ is the mean of the treatment group, ${\bar {x}}_{2}$ is the mean of the control group, $s$ is the pooled standard deviation, $n_{1}$ and $n_{2}$ are the sample sizes of the treatment and control groups, respectively, and $s_{1}$ and $s_{2}$ are the standard deviations of the treatment and control groups, respectively.


```{r}
cd_between <- function(x) {
  
  cohensd <- c()  
  
  for (k in 1:nrow(x)) {
    
    nc <- as.numeric(x$nc_ps)[k]
    nt <- as.numeric(x$nt_ps)[k]
    
    mc <-  as.numeric(x$mc_ps.2)[k]
    mt <-  as.numeric(x$mt_ps.2)[k]
    sdc <- as.numeric(x$sdc_ps.2)[k]
    sdt <- as.numeric(x$sdt_ps.2)[k]
    
    
    if (df$data_available[k] == "yes") {
      d <- ((mt - mc) / sqrt((((nc - 1) * (sdc^2)) + ((nt - 1) * (sdt^2))) / (nc + nt - 2)))
    } else {
      d <- as.numeric(df$smd_ma)[k]
    }    
    

    cohensd[k] <- d
    
  }
  return(cohensd)
}
```


#### Hedges' $g$ for a between-groups comparison
Hedges' $g$ is a small sample correction of Cohen's $d$, one way to compute it can be found in [Hedges and Olkin (1985, p. 81)](https://www.sciencedirect.com/book/9780080570655/statistical-methods-for-meta-analysis):
$$d={\frac {{\bar {x}}_{1}-{\bar {x}}_{2}}{s}}={\frac {\mu_{1}-\mu_{2}}{s}}$$

$$s={\sqrt {\frac {(n_{1}-1)s_{1}^{2}+(n_{2}-1)s_{2}^{2}}{n_{1}+n_{2}-2}}}$$

$$J={1-{\frac {3}{4N-9}}}$$

$$g=J \times d$$
Where $N = n_{1}+n_{2}$

```{r}
hg_between <- function(x) {
  
  hedgesg <- c()  
  
  for (k in 1:nrow(x)) {
    
    nc <- as.numeric(x$nc_ps)[k]
    nt <- as.numeric(x$nt_ps)[k]
    n <- nc + nt
    
    mc <-  as.numeric(x$mc_ps.2)[k]
    mt <-  as.numeric(x$mt_ps.2)[k]
    sdc <- as.numeric(x$sdc_ps.2)[k]
    sdt <- as.numeric(x$sdt_ps.2)[k]
    
    d <- (mt - mc) / sqrt((((nc - 1) * (sdc^2)) + ((nt - 1) * (sdt^2))) / (nc + nt - 2))
    # the f-else function was added to the Cohen's d function later. no need for it here since 
    # this meta-analysis used Cohen's ds, as demonstrated below
    
    # transform to hedges g
    J <- 1 - (3 / ((4 * n) - 9))  
    hedgesg[k] <- J * d
  }
  return(hedgesg)
}
```

### Reproduce primary SMDs
17 primary studies were included in MA1, based on which 21 comparisons were made and thus 21 SMDs calculated. Two comparisons were made based on studies 5, 6, 7 and 14, which had three groups: anodal, cathodal, and sham tDCS in contrast to the other studies which either had one type of tDCS or combined both types into one group. Hence, effect sizes/comparison ids 5 & 6, 7 & 8, 9 & 10, and 17 & 18 are based on identical control/sham groups.
```{r}
df$smd_r_d <- cd_between(df)
df$smd_r_g <- hg_between(df)
# put relevant columns next to each other to facilitate inspection
df <- df %>% relocate(data_available, .before = smd_r_d)
df <- df %>% relocate(smd_ma, .after = smd_r_g)
df <- df %>% relocate(24:27, .after = author)
```
Enough data were available to reproduce 8 out of the 21 effect sizes: comparison ids 4,5,6, 11, 14, 16, 17, and 18. Since the calculated Cohen's ds are almost identical to the SMDs reported in the MA, these will be used for computing the pooled SMD. Before double checking correct data extraction, 4 out of the 8 reproduced primary SMDs were equal to the reported ones after rounding to the second decimal place. For comparisons 11, 16, 17, and 18, the reproduced SMD did not equal the reported one. Data extraction for these comparisons was double checked:

* For comparison 11, the reproduced SMD was the negative of the reported one, indicating the meta-analysts reversed the sign as a reduction on the specific scale used in that study means improvement (SMD No. 11 was made positive below). Thus, this primary SMD can be seen as reproducible, which brings the number of reproducible SMDs to 5.

* For comparison 16, it turns out the means and SDs of changes were extracted, not the raw means and SDs, which were not reported in the PS. These values were removed below. Thus, the number of comparisons for which enough data is available is down to 7.

* For comparisons 17 and 18, both from PS 14, I could not find any errors in my data collection. However, since A. the meta-analysis specified "FMA" as the outcome measure used to compute the primary SMD and B. PS 14 reported values on two outcomes "FMA-total" and "UL-FMA", I tried reproducing the reported primary SMDs using the "FMA-total" values after having used the "UL-FMA" with the original data extraction. Regardless of the fact that neither sets of values reproduced the original SMDs, the UL-FMA values are more likely to be the ones used the by meta-analysts as the UL-FMA has the same scale as FMA-outcome measures from other primary studies included in the meta-analysis, which is why I will use these to compute the pooled SMD.

In sum, there were enough data in the primary studies to attempt to reproduce 7 out of the 21 SMDs reported in MA1. Out of these 7 SMDs, 5 could be  reproduced using Cohen's $d$s. 

### Data wrangling - after double checking data extraction

#### Remove the Hedges' $g$s column
```{r}
df <- select(df, -"smd_r_g")
```

#### Convert SMD 11 to positive
```{r}
# Convert the reproduced SMDs to numerics
df$smd_r_d <- as.numeric(df$smd_r_d)

# Make SMD 11 positive
df[11, "smd_r_d"] <- -df[11, "smd_r_d"]
```

#### Remove the erroneous means and SDs extracted for SMD 16
```{r}
df[16, 18:21] <- NA
# change availability of data to "no" 
df[16, "data_available"] <- "no"

# replace the reproduced SMD with the SMD reported in the MA
df[16, "smd_r_d"] <-  as.numeric(df[16, "smd_ma"])
```

#### Reproduce SMDs 17 and 18 using the alternative "FMA-total" means and SDs
```{r}
#nc_ps <- c(7, 7) 
#nt_ps <- c(7, 7)
#mc_ps.2 <- c(123.1, 123.1) # "FMA-total" values
#mt_ps.2 <- c(124.7, 126.7) # "FMA-total" values
#sdc_ps.2 <- c(7.47, 7.47) # "FMA-total" values
#sdt_ps.2 <- c(6.94, 6.18) # "FMA-total" values
#smd_ma <- c(0.94, 0.24) # SMDs reported in the meta-analysis for comparison
#ps_14b <- data.frame(nc_ps, nt_ps, mc_ps.2, mt_ps.2, sdc_ps.2, sdt_ps.2, smd_ma)
#ps_14b$alternative_smd <- cd_between(ps_14b) # "alternative" as in using alternative Ms and SDs to the originally reproduced SMDs above
```

#### Round the reproduced SMDs to match reported ones
```{r}
#df$smd_r_d <- round(df$smd_r_d,digits = 2)
```

### Functions for reproducing within-study variances
#### Compute variance of Cohen's $d$ for a between-groups comparison
To compute the pooled SMD, the within-study variance for each study, $\hat\sigma_i$, must be determined. The formula used here can be found in [Hedges and Olkin (1985, p. 86)](https://www.sciencedirect.com/book/9780080570655/statistical-methods-for-meta-analysis):

$$\hat\sigma_i={\frac {n_{1}+n_{2}}{n_{1}n_{2}}}+{\frac {d^2}{2(n_{1}+n_{2})}}$$

```{r}
vd_between <- function(x) {
  
  vd <- c()  
  
  for (k in 1:nrow(x)) {
    
    nc <- as.numeric(x$nc_ps)[k]
    nt <- as.numeric(x$nt_ps)[k]
    
    d <- as.numeric(df$smd_r_d)[k]
    
    v <- ((nc + nt) / (nc*nt)) + (d^2 / (2 * (nc + nt)))
      
    vd[k] <- v
    
  }
  return(vd)
}
```


#### Compute variances of primary SMDs
```{r}
df$vd <- vd_between(df)
df <- df %>% relocate(vd, .after = smd_ma)
```
#### Confirm that the $\hat\sigma_i$s can be reproduced by already available software
```{r}
#library("MAd")

# compute ds and corresponding within study variances
#df <- compute_ds(as.numeric(nt_ps), as.numeric(mt_ps.2), as.numeric(sdt_ps.2), as.numeric(nc_ps), as.numeric(mc_ps.2), as.numeric(sdc_ps.2), df, denom = "pooled.sd")
# note that the ds are reproduced here too

# relocate to facilitate inspection
#df <- df %>% relocate(c(d, vd, var.d), .after = smd_ma)
```

At this point (07.09.21) I was reminded that, as in the case of the Cohen's $d$s themselves, the formula for computing the corresponding within-study variance wouldn't work for studies that had no control groups (cross-over trials). I contacted the authors of MA 1 on the 08.09.21 and received a reply that they used CMA to run the meta-analysis. As of 09.09.21, I'm waiting for further information.

Update 10.09.2021: I was informed by the first author of the MA that they used an [online tool](https://automeris.io/WebPlotDigitizer/) to extract means and SDs from figures when these were not reported in the primary study. This was done for the 13 RCTs that were included if they did not report means and SDs. For the 4 remaining studies (comparisons 2, 12, 13, and 21), the authors used sample sizes in combination with $t$ or $p$ values. Thus, the following sections repeat the process using an updated dataset containing data extracted from figures.
























### Load dataset & preprocess data as above
```{r}
# load updated dataset
df <- read_excel("data_thesis/Data_sheet_ps_ma1_updated.xlsx")

# add a column specifying availability of necessary data
df <- df %>% mutate(data_available = if_else(is.na(mc_ps.2), "no", "yes"))

# remove characters marking SEs, upper bounds of SE bars, or upper bounds of CIs, to convert to SDs
df[] <- lapply(df, gsub, pattern = '/', replacement = '', fixed = TRUE)
df[] <- lapply(df, gsub, pattern = '*', replacement = '', fixed = TRUE)

# make values numeric
df <- df %>% mutate_at(vars(starts_with('sd')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('mt')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('mc')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('smd')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('n')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('ci')), as.numeric)

# Convert SEs to SDs
df[3, "sdc_ps.1"] <- df[3, "sdc_ps.1"] * sqrt(10)
df[3, "sdc_ps.2"] <- df[3, "sdc_ps.2"] * sqrt(10)
df[3, "sdt_ps.1"] <- df[3, "sdt_ps.1"] * sqrt(10)
df[3, "sdt_ps.2"] <- df[3, "sdt_ps.2"] * sqrt(10)

# Convert upper bounds of SE bars extracted from figures to SDs
df[1, "sdc_ps.2"] <- (df[1, "sdc_ps.2"] - df[1, "mc_ps.2"]) * sqrt(7)
df[1, "sdt_ps.2"] <- (df[1, "sdt_ps.2"] - df[1, "mt_ps.2"]) * sqrt(7)

df[8, "sdc_ps.2"] <- (df[8, "sdc_ps.2"] - df[8, "mc_ps.2"]) * sqrt(13)
df[8, "sdt_ps.2"] <- (df[8, "sdt_ps.2"] - df[8, "mt_ps.2"]) * sqrt(14)

df[9, "sdc_ps.2"] <- (df[9, "sdc_ps.2"] - df[9, "mc_ps.2"]) * sqrt(13)
df[9, "sdt_ps.2"] <- (df[9, "sdt_ps.2"] - df[9, "mt_ps.2"]) * sqrt(13)

df[10, "sdc_ps.2"] <- (df[10, "sdc_ps.2"] - df[10, "mc_ps.2"]) * sqrt(7)
df[10, "sdt_ps.2"] <- (df[10, "sdt_ps.2"] - df[10, "mt_ps.2"]) * sqrt(6)

df[11, "sdc_ps.2"] <- (df[11, "sdc_ps.2"] - df[11, "mc_ps.2"]) * sqrt(7)
df[11, "sdt_ps.2"] <- (df[11, "sdt_ps.2"] - df[11, "mt_ps.2"]) * sqrt(5)

# Convert upper bounds of SD bars extracted from figures to SDs
df[4, "sdc_ps.2"] <- (df[4, "sdc_ps.2"] - df[4, "mc_ps.2"])
df[4, "sdt_ps.2"] <- (df[4, "sdt_ps.2"] - df[4, "mt_ps.2"])

# Convert upper bounds of CI bars extracted from figures to SDs
df[20, "sdc_ps.2"] <- (df[20, "sdc_ps.2"] - df[20, "mc_ps.2"]) * sqrt(45) / 1.96
df[20, "sdt_ps.2"] <- (df[20, "sdt_ps.2"] - df[20, "mt_ps.2"]) * sqrt(45) / 1.96
```

### Reproduce primary SMDs
```{r}
cd_between <- function(x) {
  
  cohensd <- c()  
  
  for (k in 1:nrow(x)) {
    
    nc <- x$nc_ps[k]
    nt <- x$nt_ps[k]
    
    mc <-  x$mc_ps.2[k]
    mt <-  x$mt_ps.2[k]
    sdc <- x$sdc_ps.2[k]
    sdt <- x$sdt_ps.2[k]

    
    
    if (df$data_available[k] == "yes") {
      d <- ((mt - mc) / sqrt((((nc - 1) * (sdc^2)) + ((nt - 1) * (sdt^2))) / (nc + nt - 2)))
    } else {
      d <- df$smd_ma[k] # fill in the SMDs as reported in the MA if they could not be calculated based on data reported in the ps
    }    
    

    cohensd[k] <- d
    
  }
  return(cohensd)
}
```
Since this function automatically fills in the reported SMD when one of the necessary values (mean) is missing, it does so erroneously for one ps (nr. 10, SMD 13) which did not report the means and SDs but did report an SMD, see the following chunk.
```{r}
# use the function to calculate the SMDs for which enough data is available and fill in the rest with the SMDs reported in the MA
df$smd_r_d <- cd_between(df)

# replace the SMD filled in by the function with the SMD reported in the ps
df[13, "smd_r_d"] <- df[13, "smd_ps"]

# take the absolute value of all SMDs since some SMDs were calculated using negatively coded variables
df$smd_r_d <- abs(df$smd_r_d)

# Relocate to facilitate inspection

df <- df %>% relocate(data_available, .before = smd_r_d)
df <- df %>% relocate(smd_ma, .after = smd_r_d)
df <- df %>% relocate(24:26, .after = author)
```
Since the reproduced SMD 20 is implausibly large (probably because it was calculated based on means and SDs extracted from a figure representing values after adjusting for covariates and not raw means and SDs), it was replaced by the reported SMD. 
```{r}
df[20, "smd_r_d"] <- df[20, "smd_ma"]

# change availability of data to "no" 
df[20, "data_available"] <- "no"

# round the reproduced smds to facilitate comparison
df$smd_r_d_rounded <- round(df$smd_r_d,digits = 2)
df <- df %>% relocate(smd_r_d_rounded, .after = smd_ma)
```
After the second data extraction using figures, means and SDs were available for 13 out of the 21 comparisons, that is, 9 out of the 13 controlled trial studies included in the MA. No appropriate figures, test statistics, or $p$ values were found in the remaining 4 controlled trial studies or in the 4 cross-over studies that could be used in combination with sample sizes to reasonably estimate Cohen's $d$s. However, one of the cross-over trial studies reported an SMD.

Out of the 14 SMDs for which enough data were available (13 means and SDs, 1 reported SMD), 6 could be reproduced exactly after rounding to the second digit, 5 could be reasonably approximated as to allow for assuming that the deviations were due to slight variations in how values were extracted from figures, 2 could not be reproduced with larger deviations (reproduced SMD - reported SMD =~ -.76 and .03), and 1 was the reported SMD in the cross-over study (ps 13), which the meta-analysts did not use in their MA.

### Reproduce variances of the primary SMDs

```{r}
df$vi_ma_f <- c(0.534502924, 0.335672515, 0.450292398, 0.603508772, 0.450292398, 0.266666667, 0.264327485, 0.440935673, 0.41871345, 0.591812865, 0.649122807, 0.562573099, 0.264327485, 0.449122807, 0.528654971, 0.596491228, 0.281871345, 0.535672515, 0.458479532, 0.216374269, 0.476023392)^2
```

```{r}
vd_between <- function(x) {
  
  vd <- c()  
  
  for (k in 1:nrow(x)) {
    
    nc <- x$nc_ps[k]
    nt <- x$nt_ps[k]
    
    d <- df$smd_r_d[k]
    
    if (df$data_available[k] == "yes") {
      v <- ((nc + nt) / (nc*nt)) + (d^2 / (2 * (nc + nt)))
    } else {
      v <- df$vi_ma_f[k] # take the variances based on the SEs extracted from the funnel plot in the MA if the variances could not be calculated based on data reported in the ps
    }

    vd[k] <- v
    
  }
  return(vd)
}
```



```{r}
df$vi_r <- vd_between(df)
# compare the variances calculated based on the ps data with the ones calculated on the CIs reported in the MA
df$vi_ma <- ((df$ciu_ma - df$smd_ma)  / 1.96)^2
df <- df %>% relocate(50:51, .after = smd_ma)
```
The variances calculated based on the reproduced Cohen's $d$s and sample sizes approximated those calculated using the CIs reported in the MA in most, but not all cases. The confidence intervals must have been computed using varying formulas (which is not implausible given the variable designs of the studies included in the MA).

### Reproduce the pooled SMD
#### Meta-analysis using the Cohen's $d$s & the variances calculated based on the CIs reported in the MA
```{r}
rm <- rma(smd_ma, vi_ma, data = df, method = "DL") # DerSimonian-Laird is the default between-study heterogeneity estimator in the CMA software
rm
```
The reproduced PSMD is 0.0469067 larger than the one reported in the MA. The heterogeneity parameters $\tau^2$, $Q$, and $I^2$ could not be reproduced, either.

#### Meta-analysis using the Cohen's $d$s & the weights reported in the MA
```{r}
rm <- rma(smd_ma, vi_ma, weights = weights_ma, data = df, method = "DL")
rm
```
By weighing the SMDs by the weights reported in the MA instead of the within-study variances calculated based on the reported CIs, the pooled SMD could be reproduced.

#### Meta-analysis using the reproduced Cohen's $d$s & variances
```{r}
rm_r <- rma(smd_r_d, vi_r, data = df, method = "DL")
rm_r
```
The reproduced PSMD is 0.0637099 larger than the one reported in the MA. The heterogeneity parameters are considerably larger than the reported ones.


#### Meta-analysis using the SMDs reported in the MA and SEs extracted from the funnel plot in the MA
It occurred to me to extract the SEs from the figure while working on the publication bias analysis section (see below). This extraction followed the steps: 1. extract the SMDs and the corresponding SEs using Webplotdigitizer, 2. Find the SMD reported in the MA that corresponds to each SMD extracted from the figure, 3. assign each SE paired with a figure-extracted SMD to its corresponding reported SMD.

```{r}
# SES extracted from the funnel plot, correctly ordered
df$vi_ma_f <- c(0.534502924, 0.335672515, 0.450292398, 0.603508772, 0.450292398, 0.266666667, 0.264327485, 0.440935673, 0.41871345, 0.591812865, 0.649122807, 0.562573099, 0.264327485, 0.449122807, 0.528654971, 0.596491228, 0.281871345, 0.535672515, 0.458479532, 0.216374269, 0.476023392)^2
rm_o <- rma(smd_ma, vi_ma_f, data = df, method = "DL")
rm_o
```
These results (including the heterogeneity parameters) correspond very closely to the reported ones. 

**UPDATE AFTER EXTRACTING DATA FOR MA2 AND MA3**
Since my data extraction procedure was somewhat different for MA2 and MA3, I did a final round of data extraction for MA1 so that my treatment is the same of all three meta-analyses. 

### Load dataset & preprocess data - final
```{r}
df <- read_excel("data_thesis/Data_ps_raw_updated.xlsx", sheet = "MA1")


# remove characters marking SEs, upper bounds of SE bars, or upper bounds of CIs, to convert to SDs
df[] <- lapply(df, gsub, pattern = '/', replacement = '', fixed = TRUE)
df[] <- lapply(df, gsub, pattern = '*', replacement = '', fixed = TRUE)

# make values numeric
df <- df %>% mutate_at(vars(starts_with('sd')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('mt')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('mc')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('smd')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('n')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('ci')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('p_')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('t_')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('F_')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('se')), as.numeric)

# Convert SEs to SDs
df[3, "sdc_ps.1"] <- df[3, "sdc_ps.1"] * sqrt(10)
df[3, "sdt_ps.1"] <- df[3, "sdt_ps.1"] * sqrt(10)

# Convert upper bounds of SE bars extracted from figures to SDs
df[1, "sdc_ps.1"] <- (df[1, "sdc_ps.1"] - df[1, "mc_ps.1"]) * sqrt(7)
df[1, "sdt_ps.1"] <- (df[1, "sdt_ps.1"] - df[1, "mt_ps.1"]) * sqrt(7)

df[2, "sdc_ps.1"] <- (df[2, "sdc_ps.1"] - df[2, "mc_ps.1"]) * sqrt(9)
df[2, "sdt_ps.1"] <- (df[2, "sdt_ps.1"] - df[2, "mt_ps.1"]) * sqrt(9)

df[8, "sdc_ps.1"] <- (df[8, "sdc_ps.1"] - df[8, "mc_ps.1"]) * sqrt(13)
df[8, "sdt_ps.1"] <- (df[8, "sdt_ps.1"] - df[8, "mt_ps.1"]) * sqrt(14)

df[9, "sdc_ps.1"] <- (df[9, "sdc_ps.1"] - df[9, "mc_ps.1"]) * sqrt(13)
df[9, "sdt_ps.1"] <- (df[9, "sdt_ps.1"] - df[9, "mt_ps.1"]) * sqrt(13)

df[10, "sdc_ps.1"] <- (df[10, "sdc_ps.1"] - df[10, "mc_ps.1"]) * sqrt(7)
df[10, "sdt_ps.1"] <- (df[10, "sdt_ps.1"] - df[10, "mt_ps.1"]) * sqrt(6)

df[11, "sdc_ps.1"] <- (df[11, "sdc_ps.1"] - df[11, "mc_ps.1"]) * sqrt(7)
df[11, "sdt_ps.1"] <- (df[11, "sdt_ps.1"] - df[11, "mt_ps.1"]) * sqrt(5)

# Convert upper bounds of SD bars extracted from figures to SDs
df[4, "sdc_ps.1"] <- (df[4, "sdc_ps.1"] - df[4, "mc_ps.1"])
df[4, "sdt_ps.1"] <- (df[4, "sdt_ps.1"] - df[4, "mt_ps.1"])

# Convert upper bounds of CI bars extracted from figures to SDs
df[20, "sdc_ps.1"] <- (df[20, "sdc_ps.1"] - df[20, "mc_ps.1"]) * sqrt(45) / 1.96
df[20, "sdt_ps.1"] <- (df[20, "sdt_ps.1"] - df[20, "mt_ps.1"]) * sqrt(45) / 1.96
```

```{r}
# average group sample size
mean((df$nc_ma + df$nt_ma) / 2)
```



### Reproduce primary SMDs
3 meta-analytic models were fit:

1. Using the SMDs reproduced strictly following information given in the meta-analysis or a standard procedure apparently adopted for at least 2 other primary SMDs (e.g., Cohenâ€™s $d$ of tDCS vs. Sham at post intervention).
2. Using the SMDs reproduced strictly following information given in the meta-analysis or a standard procedure apparently adopted for at least 2 other primary SMDs + SMDs that could be successfully reproduced (i.e., reproduced SMD = reported SMD) following a procedure which __either__ does not entirely correspond to what the meta-analysts report having adopted __or__ does not (necessarily) produce an SMD that is comparable to what would result from following the procedure apparently adopted for at least 2 other primary SMDs
3. Using the reported SMDs only (reproduce fitting the MA model using values reported in the MA only)

#### Between-groups studies which reported sample sizes, means and SDs (SEs/CIs)
```{r}
df <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")
df$d <- abs(df$d)

# relocate to facilitate inspection
df <- df %>% relocate(c(id_comparison, d, smd_ma), .after = dv_ps)
```
The SMDs that could not be reproduced or approximated (those based on values from figures can only be approximated due to variations in how values were extracted from figures):  (4/17 comparisons from between-groups studies). 
Reproduced SMDs 16, 17, 18, and 20 deviate from the reported ones beyond what would be expected as a result of rounding or differences in how values were extracted from figures. For SMDs 16 and 20, other values could have been used:

For SMD 16, another set of means and SDs could have been used:
```{r}
compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[16]]
```
Reproduces reported SMD successfully.

SMD 20 had corresponding $p$-value:
```{r}
p_to_d1(df$p_ps[[20]], df$nt_ps[[20]], df$nc_ps[[20]])[1]
p_to_d2(df$p_ps[[20]], df$nt_ps[[20]], df$nc_ps[[20]])[1]
```


The SMD based on the two tailed $p$ value successfully reproduces the reported SMD.

#### Crossover studies which reported sample sizes, means and SDs (SEs/CIs)
Since the meta-analysts listed the sample size of both the treatment and control group as = $N$ = the number of participants, I use N as the sample size of both groups even though there aren't two groups:
```{r}
df2 <- df %>% filter(is.na(nc_ps))
df2 <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df2, denom = "pooled.sd")
```
Reproduced SMDs 12, 13, 21 deviate from the reported ones beyond what would be expected as a result of rounding or differences in how values were extracted from figures. For SMDs 12 and 13, other values could have been used:
SMDs 12 and 13 had another set of means and SDs:
```{r}
compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[12]]
compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[13]]
```
Still not reproducible. SMD 13 does reproduce the Cohen's $d$ reported in the primary study, though. 

### Overview of SMDs post double checking irreproducible SMDs
Data extraction was correct for all SMDs and no further data were extracted.

1. SMD 1 successfully reproduced
2. approximated (values extracted from figure)
3. successfully reproduced
4. approximated
5. successfully reproduced
6. successfully reproduced
7. successfully reproduced
8. irreproducible
9. irreproducible
10. approximated
11. approximated
12. irreproducible. SMD based on the first set of means and SDs will be used for MA model 2  (according to definition above) since the control values here are the baseline (0) values which corresponds more or less to the meta-analysts' description of their procedure "baseline: Ctrl".
13. irreproducible. SMD based on the first set will be used for MA model 2 since the control values here are the baseline (0) values which corresponds more or less to the meta-analysts' description of their procedure "baseline: Ctrl".
14. successfully reproduced
15. approximated
16. irreproducible using the values purported to have been used by the meta-analysts "3J-ROM(ctDCS on cH during OT at retention: Rx vs sham during OT at retention: Ctrl)", successfully reproduced using "Proportional change in 3J-ROM" values. The SMD based on the latter values will be used for MA model 2 .
17. irreproducible. 
18. irreproducible.
19. successfully reproduced but not according to the information given in the MA. the values used are for changes in JHFT time from baseline whereas the meta-analysts report using "Time in JHFT".
20. successfully reproduced using a $p$-value based on differences in medians. will be used for  MA model 2.
21. irreproducible.

### Collate reproduced primary SMDs for MA model 1
```{r}
# SMDs which were successfully reproduced using the first set of means and SDs, in accordance with information in MA
df$smd_re1 <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$d

df$smd_re1[[2]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$d[[2]]

# SMDs which could not be reproduced using the first set of means and SDs, in accordance with information in MA
df$smd_re1[[21]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$d[[21]]

# SMDs which were successfully reproduced using values that either do not quite correspond to the information given in the MA or the standard method adopted for the other SMDs
# df$smd_re1[[16]] <- NA WRONG ==> use the 

df$smd_re1[[19]] <- NA

df$smd_re1[[20]] <- NA

# SMDs which could not be reproduced using values that either do not quite correspond to the information given in the MA or the standard method adopted for the other SMDs
df$smd_re1[[12]] <- NA

df$smd_re1[[13]] <- NA
  
# make numeric and positive
df$smd_re1 <- df$smd_re1 %>% as.numeric() %>% abs()

# relocate to check if everything's fine
df <- df %>% relocate(c(id_comparison, smd_re1, smd_ma), .after = dv_ps)
```


### Collate reproduced primary SMDs for MA model 2
```{r}
# SMDs which were successfully reproduced using the first set of means and SDs, in accordance with information in MA
df$smd_re2 <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$d

df$smd_re2[[2]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$d[[2]]

# SMDs which could not be reproduced using the first set of means and SDs, in accordance with information in MA
df$smd_re2[[21]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$d[[21]]

# SMDs which were successfully reproduced using values that either do not quite correspond to the information given in the MA or the standard method adopted for the other SMDs
df$smd_re2[[16]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[16]]

df$smd_re2[[19]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$d[[19]]

df$smd_re2[[20]] <- p_to_d2(df$p_ps[[20]], df$nt_ps[[20]], df$nc_ps[[20]])[1]

# SMDs which could not be reproduced using values that either do not quite correspond to the information given in the MA or the standard method adopted for the other SMDs
df$smd_re2[[12]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$d[[12]]

df$smd_re2[[13]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$d[[13]]
  
# make numeric and positive
df$smd_re2 <- df$smd_re2 %>% as.numeric() %>% abs()

# relocate to check if everything's fine
df <- df %>% relocate(smd_re2, .after = smd_re1)
```

### Proportion of successfully reproduced primary SMDs strictly following information given in the MA
#### reproducible to the second decimal place
```{r}
df <- transform(df, rep_1_sec_dec = ifelse(round(smd_re1, digits = 2) == smd_ma, 1, 0))
sum(df$irrep_1_sec_dec, na.rm = TRUE)
sum(df$irrep_1_sec_dec, na.rm = TRUE)/21 * 100
```
#### reproducible to the first decimal place
```{r}
df <- transform(df, rep_1_fir_dec = ifelse(round(smd_re1, digits = 1) == round(smd_ma, digits = 1), 1, 0))
sum(df$rep_1_fir_dec, na.rm = TRUE)
sum(df$rep_1_fir_dec, na.rm = TRUE)/21 * 100
```
### Proportion of successfully reproduced primary SMDs brute force
#### reproducible to the second decimal place
```{r}
df <- transform(df, rep_2_sec_dec = ifelse(round(smd_re2, digits = 2) == smd_ma, 1, 0))
sum(df$rep_2_sec_dec, na.rm = TRUE)
sum(df$rep_2_sec_dec, na.rm = TRUE)/21 * 100
```
#### reproducible to the first decimal place
```{r}
df <- transform(df, rep_2_fir_dec = ifelse(round(smd_re2, digits = 1) == round(smd_ma, digits = 1), 1, 0))
sum(df$rep_2_fir_dec, na.rm = TRUE)
sum(df$rep_2_fir_dec, na.rm = TRUE)/21 * 100

df <- df %>% relocate(c(id_comparison, rep_1_sec_dec, rep_2_sec_dec, rep_1_fir_dec, rep_2_fir_dec, smd_re1, smd_re2, smd_ma), .after = id_ps)
```



### Reproduce variances of the primary SMDs for MA model 1
`MAd`'s `compute_ds()` and `p_to_d1` functions automatically calculate the corresponding sampling/within-study variances. In cases where not enough data were available, the square of the standard error extracted from the funnel plot in the MA will be used.
```{r}
# SMDs which were successfully reproduced using the first set of means and SDs, in accordance with information in MA
df$v_re1 <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$var.d

df$v_re1[[2]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$var.d[[2]]

# SMDs which could not be reproduced using the first set of means and SDs, in accordance with information in MA
df$v_re1[[21]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$var.d[[21]]

# SMDs which were successfully reproduced using values that either do not quite correspond to the information given in the MA or the standard method adopted for the other SMDs
# df$v_re1[[16]] <- NA

df$v_re1[[19]] <- NA

df$v_re1[[20]] <- NA

# SMDs which could not be reproduced using values that either do not quite correspond to the information given in the MA or the standard method adopted for the other SMDs
df$v_re1[[12]] <- NA

df$v_re1[[13]] <- NA
  
# make numeric
df$v_re1 <- as.numeric(df$v_re1)

# relocate to check if everything's fine
df$v_ma <- df$se_ma^2
df <- df %>% relocate(c(id_comparison, v_re1, v_ma), .after = dv_ps)
```


### Reproduce variances of the primary SMDs for MA model 2
```{r}
# SMDs which were successfully reproduced using the first set of means and SDs, in accordance with information in MA
df$v_re2 <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$var.d

df$v_re2[[2]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$var.d[[2]]

# SMDs which could not be reproduced using the first set of means and SDs, in accordance with information in MA
df$v_re2[[21]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$var.d[[21]]

# SMDs which were successfully reproduced using values that either do not quite correspond to the information given in the MA or the standard method adopted for the other SMDs
df$v_re2[[16]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$var.d[[16]]

df$v_re2[[19]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$var.d[[19]]

df$v_re2[[20]] <- p_to_d2(df$p_ps[[20]], df$nt_ps[[20]], df$nc_ps[[20]])[2]

# SMDs which could not be reproduced using values that either do not quite correspond to the information given in the MA or the standard method adopted for the other SMDs
df$v_re2[[12]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$var.d[[12]]

df$v_re2[[13]] <- df$smd_re2[[13]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$var.d[[13]]

  
# make numeric
df$v_re2 <- as.numeric(df$v_re2)

# relocate to check if everything's fine
df$v_ma <- df$se_ma^2
df <- df %>% relocate(c(id_comparison, v_re2, v_ma), .after = dv_ps)
```

### Reproduce the pooled SMD
#### MA model 1
```{r}
ma1 <- metagen(TE = smd_re1,
              seTE = sqrt(v_re1),
              studlab = id_comparison,
              data = df,
              sm = "SMD",
              fixed = FALSE,
              random = TRUE, # a random effects MA
              method.tau = "DL", # DerSimonian-Laird estimator
                 )
windowsFonts(A = windowsFont("Times New Roman"))

png("figures/fig3_mam1.png", units = "in", width = 7.2, height = 6, res = 300)
forest.meta(ma1,
           fontfamily = "A",
           print.tau2 = TRUE,
           leftlabs = c("SMD No.", "d", "SE"))
```

#### MA model 2
```{r}
ma2 <- metagen(TE = smd_re2,
              seTE = sqrt(v_re2),
              studlab = id_comparison,
              data = df,
              sm = "SMD",
              fixed = FALSE,
              random = TRUE, # a random effects MA
              method.tau = "DL", # DerSimonian-Laird estimator
                 )
png("figures/fig3_mam2.png", units = "in", width = 7.2, height = 6, res = 300)
forest.meta(ma2,
           fontfamily = "A",
           print.tau2 = TRUE,
           leftlabs = c("SMD No.", "d", "SE"))
```

#### MA model 3
```{r}
ma3 <- metagen(TE = smd_ma,
              seTE = se_ma,
              studlab = id_comparison,
              data = df,
              sm = "SMD",
              fixed = FALSE,
              random = TRUE, # a random effects MA
              method.tau = "DL", # DerSimonian-Laird estimator
                 )
png("figures/fig3_mam3.png", units = "in", width = 7.2, height = 6, res = 300)
forest.meta(ma3,
           fontfamily = "A",
           print.tau2 = TRUE,
           leftlabs = c("SMD No.", "d", "SE"))
```







## Publication bias analysis
The analysis in this section mostly follows the tutorial [here](https://bookdown.org/MathiasHarrer/Doing_Meta_Analysis_in_R/pub-bias.html#addressing-pubbias).

### PET-PEESE
#### Collate the necessary variables
For the PET-PEESE model, the effect sizes (here SMDs), their SEs, their variances, and their inverse-variance weights, are needed.
```{r}
petpeese <- data.frame(smd = df$smd_ma) # smds
petpeese$v <- df$v_ma # within-study variances (extracted from the figures)
petpeese$se <- df$se_ma # standard errors of SMD estimates
petpeese$w <- 1/petpeese$v # inverse variance weights
```

#### PET (precision-effect test)
```{r}
pet <- lm(smd ~ se, weights = w, data = petpeese)
summary(pet)$coefficients
```

#### PEESE (precision-effect estimate with standard error)
```{r}
peese <- lm(smd ~ v, weights = w, data = petpeese)
summary(peese)$coefficients
```
Both estimates indicate the presence of publication bias since they're smaller than the original.


### P-Curve

#### P-Curve
```{r}
pcurve(ma3, 
       effect.estimation = TRUE,
       N = df$nt_ma + df$nc_ma, 
       dmin = 0,
       dmax = 1)
```
No indication of bias.


### Three-parameter selection model
#### Create a `metafor` package meta-analysis object, necessary for the `selmodel` function
```{r}
ma3_metafor <- rma(yi = smd_ma,        
          sei = se_ma,
          data = df,
          method = "DL")
```

#### Fit the selection model
```{r}
selmodel(ma3_metafor,
         type = "stepfun",
         steps = 0.025)
```
No indication of bias.


## Outlier/influence diagnostics
### Leave-one-out analysis
```{r}
metainf(ma3, pooled = "random")
```
Removing SMD 8 would reduce the pooled SMD by ~ 0.05 and considerably reduce the variance.

### Some plots
#### Baujat 
```{r}
outl <- InfluenceAnalysis(ma3, random = TRUE, text.scale = 2)
png("figures/fig6.png", units = "in", width = 5, height = 5, res = 300)
plot(outl, "baujat")
```

#### Forest plot
```{r}
plot(outl, "ES")
```


SMDs 6, 7, and 8 contribute disproportionately to both the variance and the pooled SMD.

### Run meta-analysis without outliers
```{r}
s <- update.meta(ma3, subset = -c(6, 7, 8))
forest.meta(s,

            print.tau2 = TRUE,
            leftlabs = c("SMD No.", "d", "SE"))
```
Removing the outliers increases the pooled SMD by ~ 0.7 and eliminates between-study heterogeneity altogether.

# Meta-analysis 2

## Reproducibility

### Load dataset & preprocess data
```{r}
df <- read_excel("data_thesis/Data_ps_raw_updated.xlsx", sheet = "MA2")


# remove characters marking SEs, upper bounds of SE bars, or upper bounds of CIs, to convert to SDs
df[] <- lapply(df, gsub, pattern = '/', replacement = '', fixed = TRUE)
df[] <- lapply(df, gsub, pattern = '*', replacement = '', fixed = TRUE)

# make values numeric
df <- df %>% mutate_at(vars(starts_with('sd')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('mt')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('mc')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('smd')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('n')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('ci')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('p_')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('t_')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('F_')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('se')), as.numeric)

# Convert upper bounds of SE bars extracted from figures to SDs
df[10, "sdc_ps.1"] <- (df[10, "sdc_ps.1"] - df[10, "mc_ps.1"]) * sqrt(13)
df[10, "sdt_ps.1"] <- (df[10, "sdt_ps.1"] - df[10, "mt_ps.1"]) * sqrt(13)

df[11, "sdc_ps.1"] <- (df[11, "sdc_ps.1"] - df[11, "mc_ps.1"]) * sqrt(13)
df[11, "sdt_ps.1"] <- (df[11, "sdt_ps.1"] - df[11, "mt_ps.1"]) * sqrt(13)

df[12, "sdc_ps.1"] <- (df[12, "sdc_ps.1"] - df[12, "mc_ps.1"]) * sqrt(6)
df[12, "sdt_ps.1"] <- (df[12, "sdt_ps.1"] - df[12, "mt_ps.1"]) * sqrt(7)

df[18, "sdc_ps.1"] <- (df[18, "sdc_ps.1"] - df[18, "mc_ps.1"]) * sqrt(13)


# Convert lower bounds of SE bars extracted from figures to SDs
df[13, "sdc_ps.1"] <- (df[13, "sdc_ps.1"] + df[13, "mc_ps.1"]) * sqrt(25)
df[13, "sdt_ps.1"] <- (df[13, "sdt_ps.1"] + df[13, "mt_ps.1"]) * sqrt(25)

df[18, "sdt_ps.1"] <- (df[18, "sdt_ps.1"] + df[18, "mt_ps.1"]) * sqrt(13)
```

```{r}
# average group sample size
mean((df$nc_ma + df$nt_ma) / 2)
```

### Reproduce primary SMDs
#### Between-groups studies which reported sample sizes, means and SDs (SEs/CIs)
```{r}
#df <- compute_dgs(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")
# relocate to facilitate inspection
#df <- df %>% relocate(c(d, g, smd_ma), .after = dv_ps)
```

For PSs that reported means and SDs (no extraction from figure necessary), all reported SMDs were approximated better by Cohen's $d$s than Hedges' $g$s. I will thus assume the authors used Cohen's $d$s:

```{r}
df <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")

# relocate to facilitate inspection
df <- df %>% relocate(c(id_comparison, d, smd_ma), .after = dv_ps)
```


Reproduced SMDs 6, 7, 9, 12, 14, 15 deviate from the reported ones beyond what would be expected as a result of rounding or differences in how values were extracted from figures. For SMDs 6, 7, 14, and 15, other values could have reasonably been used:

SMDs 6 and 7 had corresponding $p$-values:
```{r}
# one-tailed p-value + sample sizes to d
p_to_d1(0.925, 6, 5)[1]
p_to_d1(0.897, 6, 5)[1]

# two-tailed p-value + sample sizes to d
p_to_d2(0.925, 6, 5)[1]
p_to_d2(0.897, 6, 5)[1]
```
Since these are even further from the ones based on means and SDs, data extraction was double checked for correctness (see below).


For SMDs 14 and 15, two other sets of means and SDs could have been used:
```{r}
# Set 2
compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[14]]
compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[15]]

# Set 3
compute_ds(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.3, sdc_ps.3, data = df, denom = "pooled.sd")$d[[14]]
compute_ds(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.3, sdc_ps.3, data = df, denom = "pooled.sd")$d[[15]]
```
Values of set 2 are much closer, but not quite identical.


#### Crossover studies which reported sample sizes, means and SDs (SEs/CIs)
Since the meta-analysts listed the sample size of both the treatment and control group as = $N$ = the number of participants, I use N as the sample size of both groups even though there aren't two groups:
```{r}
df2 <- df %>% filter(is.na(nc_ps))
df2 <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df2, denom = "pooled.sd")
```
Reproduced SMDs 1, 2, 4, 5, 13, 20 deviate from the reported ones beyond what would be expected as a result of rounding or differences in how values were extracted from figures. For SMDs 1, 2, 4, 5, and 20, other values could have reasonably been used:

SMD 1 had two other sets of means and SDs and a corresponding $p$ value:
```{r}
# Set 2
compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[1]]


# Set 3
compute_ds(n_ps, mt_ps.3, sdt_ps.3, n_ps, mc_ps.3, sdc_ps.3, data = df, denom = "pooled.sd")$d[[1]]

# p-value
p_to_d1(df$p_ps[[1]], df$n_ps[[1]], df$n_ps[[1]])[1]
p_to_d2(df$p_ps[[1]], df$n_ps[[1]], df$n_ps[[1]])[1]
```
The $d$ based on the one-tailed $p$-values is closest.

SMD 2 had a corresponding $p$ value:
```{r}
p_to_d1(df$p_ps[[2]], df$n_ps[[2]], df$n_ps[[2]])[1]
p_to_d2(df$p_ps[[2]], df$n_ps[[2]], df$n_ps[[2]])[1]
```
Closer.

SMDs 4, 5, and 20 had another set of means and SDs:
```{r}
compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[4]]
compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[5]]
compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[20]]
```
Nope.

#### Studies which did not report means and/or SDs (SEs/CIs)
For SMD 8, only means were reported. Computing an SMD is thus not possible. For SMD 19 no means or SDs were reported but a potentially suitable $p$-value:
```{r}
p_to_d1(df$p_ps[[19]], df$n_ps[[19]], df$n_ps[[19]])[1]
p_to_d2(df$p_ps[[19]], df$n_ps[[19]], df$n_ps[[19]])[1]
```
The one-tailed one is close enough. 

For SMD 3, an SMD was reported in the primary study which was close to the one reported in the MA.


### Reproduce primary SMDs -- post double-checking data-extraction for irreproducible SMDs
Overview of the results of double-checking data extraction for each of the 20 primary SMDs:

1. Data extraction correct, primary SMD irreproducible. The SMD based on the $p$-value is closer to the reported one but will not be used for reproducing the pooled SMD because the $p$-value is for the comparison tDCS_post vs. tDCS_pre and not tDCS_post vs. sham_post (which is supposed to be the outcome). The SMD based on the second set of means and SDs will be used because it's closest to the reported one even though the means and SDs are raw and not "change in PPT".
2. Data extraction correct, primary SMD irreproducible. The SMD based on the $p$-value is closer to the reported one but will not be used for reproducing the pooled SMD because the $p$-value is for the comparison in the improvement from baseline between tDCS condition, not "JTT (sham vs. ctDCS at post)" (which is supposed to be the outcome). The reproduced SMD based on the means and SDs will be used for the pooled SMD.
3. The SMD reported in the primary study will be used to reproduce the pooled SMD. The SMD is for improvement of tDCS group from baseline ==> model 2
4. Data extraction correct, primary SMD irreproducible. The SMD based on the first set of means and SDs will be used because it's the percentage of change means and SDs, which is supposed to be the outcome used in the MA.
5. Data extraction correct, primary SMD irreproducible. The SMD based on the second set of means and SDs will be used because they are derived by separating the N = 9 into two groups n = 6 and 3, respectively, which is how the meta-analysts report having done it.
6. Since the means and SDs from the first set are for changes in the outcome and not raw, I extracted raw means and SDs from figures. SMDs based on these values will be used for the pooled SMD. The SMD is approximated
7. Since the means and SDs from the first set are for changes in the outcome and not raw, I extracted raw means and SDs from figures. SMDs based on these values will be used for the pooled SMD. The SMD is irreproducible.
8. successfully reproduced using a $p$ value for the comparison between the 3 groups cathodal, anodal and sham at post, will be used for MA model 2
9. Data extraction correct, primary SMD irreproducible. successfully reproduced using a $p$ value for the comparison between the 3 groups cathodal, anodal and sham at post, will be used for MA model 2
10. SMD can be considered as reproducible since the difference is probably due to variation in how the means and SDs were extracted from the figure. NOPE ACCORDING TO CLASSIFICATION SCHEME
11. Same as 10, but negative since the scale used is negatively coded.
12. I made a mistake in extracting sample sizes. The SMD remains irreproducible after correction.
13. Data extraction correct, primary SMD irreproducible.
14. Data extraction correct, primary SMD irreproducible. SMDs based on set 2 are closest to the reported SMDs but these are follow up values not post. Thus the values of the first set will be used for reproducing the pooled SMD.
15. Data extraction correct, primary SMD irreproducible. SMDs based on set 2 are closed to the reported SMDs but these are follow up values not post. Thus the values of the first set will be used for reproducing the pooled SMD.
16. Data extraction correct, primary SMD irreproducible. Almost the same as the reported SMD but negative.
17. Primary SMD reproducible.
18. Same as 10, but negative since the variable is reaction time.
19. Approximated by using a $p$ value for tDCS vs. sham post comparison. Cathodal had a negative effect.
20. Data extraction correct, primary SMD irreproducible. SMD based on the second set of means and SDs will be used since it's the post values.


Reproduce SMDs 6 & 7 using values extracted from figures:
```{r}
# Convert upper bounds of SD bars extracted from figures to SDs
df[6, "sdc_ps.2"] <- (df[6, "sdc_ps.2"] - df[6, "mc_ps.2"])
df[6, "sdt_ps.2"] <- (df[6, "sdt_ps.2"] - df[6, "mt_ps.2"])

df[7, "sdc_ps.2"] <- (df[7, "sdc_ps.2"] - df[7, "mc_ps.2"])
df[7, "sdt_ps.2"] <- (df[7, "sdt_ps.2"] - df[7, "mt_ps.2"])

# Compute Cohen's ds
compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[6]]
compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[7]]
```

```{r}
2.5 * sqrt(4)
```



Reproduce SMDs 8 & 9 using $p$-values:
```{r}
p_to_d2(df$p_ps[[8]], df$nc_ps[[8]], df$nt_ps[[8]])[1]
p_to_d2(df$p_ps[[9]], df$nc_ps[[9]], df$nt_ps[[9]])[1]
```
### Collate reproduced primary SMDs for MA model 1
```{r}
df$smd_re1[[1]] <- NA

df$smd_re1[[2]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$d

df$smd_re1[[3]] <- NA

df$smd_re1[[4]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[4,], denom = "pooled.sd")$d

df$smd_re1[[5]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[5,], denom = "pooled.sd")$d

df$smd_re1[[6]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[6,], denom = "pooled.sd")$d

df$smd_re1[[7]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[7,], denom = "pooled.sd")$d

df$smd_re1[[8]] <- NA

df$smd_re1[[9]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[9,], denom = "pooled.sd")$d

df$smd_re1[[10]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[10,], denom = "pooled.sd")$d

df$smd_re1[[11]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[11,], denom = "pooled.sd")$d %>% abs()

df$smd_re1[[12]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[12,], denom = "pooled.sd")$d

df$smd_re1[[13]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[13,], denom = "pooled.sd")$d

df$smd_re1[[14]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[14,], denom = "pooled.sd")$d

df$smd_re1[[15]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[15,], denom = "pooled.sd")$d

df$smd_re1[[16]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[16,], denom = "pooled.sd")$d

df$smd_re1[[17]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[17,], denom = "pooled.sd")$d

df$smd_re1[[18]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[18,], denom = "pooled.sd")$d %>% abs()

df$smd_re1[[19]] <- -p_to_d1(df$p_ps[[19]], df$n_ps[[19]], df$n_ps[[19]])[1]

df$smd_re1[[20]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[20,], denom = "pooled.sd")$d

# make numeric
df$smd_re1 <- df$smd_re1 %>% as.numeric()

# relocate to check if everything's fine
df <- df %>% relocate(c(id_comparison, smd_re1, smd_ma), .after = dv_ps)
```




### Collate reproduced primary SMDs for MA model 2
```{r}
df$smd_re2[[1]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[1,], denom = "pooled.sd")$d

df$smd_re2[[2]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$d

df$smd_re2[[3]] <- df$smd_ps[[3]]

df$smd_re2[[4]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[4,], denom = "pooled.sd")$d

df$smd_re2[[5]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[5,], denom = "pooled.sd")$d

df$smd_re2[[6]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[6,], denom = "pooled.sd")$d

df$smd_re2[[7]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[7,], denom = "pooled.sd")$d

df$smd_re2[[8]] <- -p_to_d2(df$p_ps[[8]], df$nc_ps[[8]], df$nt_ps[[8]])[1]

df$smd_re2[[9]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[9,], denom = "pooled.sd")$d

df$smd_re2[[10]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[10,], denom = "pooled.sd")$d

df$smd_re2[[11]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[11,], denom = "pooled.sd")$d %>% abs()

df$smd_re2[[12]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[12,], denom = "pooled.sd")$d

df$smd_re2[[13]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[13,], denom = "pooled.sd")$d

df$smd_re2[[14]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[14,], denom = "pooled.sd")$d

df$smd_re2[[15]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[15,], denom = "pooled.sd")$d

df$smd_re2[[16]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[16,], denom = "pooled.sd")$d

df$smd_re2[[17]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[17,], denom = "pooled.sd")$d

df$smd_re2[[18]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[18,], denom = "pooled.sd")$d %>% abs()

df$smd_re2[[19]] <- -p_to_d1(df$p_ps[[19]], df$n_ps[[19]], df$n_ps[[19]])[1]

df$smd_re2[[20]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[20,], denom = "pooled.sd")$d

# make numeric
df$smd_re2 <- df$smd_re2 %>% as.numeric()

# relocate to check if everything's fine
df <- df %>% relocate(smd_re2, .after = smd_re1)
```


### Reproduce variances of the primary SMDs for MA model 1
```{r}
df$v_re1[[1]] <- NA

df$v_re1[[2]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$var.d

df$v_re1[[3]] <- NA

df$v_re1[[4]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[4,], denom = "pooled.sd")$var.d

df$v_re1[[5]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[5,], denom = "pooled.sd")$var.d

df$v_re1[[6]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[6,], denom = "pooled.sd")$var.d

df$v_re1[[7]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[7,], denom = "pooled.sd")$var.d

df$v_re1[[8]] <- NA

df$v_re1[[9]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[9,], denom = "pooled.sd")$var.d

df$v_re1[[10]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[10,], denom = "pooled.sd")$var.d

df$v_re1[[11]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[11,], denom = "pooled.sd")$var.d

df$v_re1[[12]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[12,], denom = "pooled.sd")$var.d

df$v_re1[[13]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[13,], denom = "pooled.sd")$var.d

df$v_re1[[14]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[14,], denom = "pooled.sd")$var.d

df$v_re1[[15]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[15,], denom = "pooled.sd")$var.d

df$v_re1[[16]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[16,], denom = "pooled.sd")$var.d

df$v_re1[[17]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[17,], denom = "pooled.sd")$var.d

df$v_re1[[18]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[18,], denom = "pooled.sd")$var.d

df$v_re1[[19]] <- p_to_d1(df$p_ps[[19]], df$n_ps[[19]], df$n_ps[[19]])[2]

df$v_re1[[20]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[20,], denom = "pooled.sd")$var.d

# make numeric
df$v_re1 <- df$v_re1 %>% as.numeric()

# relocate to check if everything's fine
df$v_ma <- df$se_ma^2

df <- df %>% relocate(c(id_comparison, v_re1, v_ma), .after = dv_ps)
```

### Reproduce variances of the primary SMDs for MA model 2
```{r}
df$v_re2[[1]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[1,], denom = "pooled.sd")$var.d

df$v_re2[[2]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$var.d

df$v_re2[[3]] <- ((df$n_ps[[3]] + df$n_ps[[3]]) / (df$n_ps[[3]]*df$n_ps[[3]])) + (df$smd_ps[[3]]^2 / (2 * (df$n_ps[[3]] + df$n_ps[[3]])))

df$v_re2[[4]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[4,], denom = "pooled.sd")$var.d

df$v_re2[[5]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[5,], denom = "pooled.sd")$var.d

df$v_re2[[6]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[6,], denom = "pooled.sd")$var.d

df$v_re2[[7]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[7,], denom = "pooled.sd")$var.d

df$v_re2[[8]] <- p_to_d2(df$p_ps[[8]], df$nc_ps[[8]], df$nt_ps[[8]])[2]

df$v_re2[[9]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[9,], denom = "pooled.sd")$var.d

df$v_re2[[10]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[10,], denom = "pooled.sd")$var.d

df$v_re2[[11]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[11,], denom = "pooled.sd")$var.d

df$v_re2[[12]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[12,], denom = "pooled.sd")$var.d

df$v_re2[[13]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[13,], denom = "pooled.sd")$var.d

df$v_re2[[14]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[14,], denom = "pooled.sd")$var.d

df$v_re2[[15]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[15,], denom = "pooled.sd")$var.d

df$v_re2[[16]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[16,], denom = "pooled.sd")$var.d

df$v_re2[[17]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[17,], denom = "pooled.sd")$var.d

df$v_re2[[18]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[18,], denom = "pooled.sd")$var.d

df$v_re2[[19]] <- p_to_d1(df$p_ps[[19]], df$n_ps[[19]], df$n_ps[[19]])[2]

df$v_re2[[20]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[20,], denom = "pooled.sd")$var.d

# make numeric
df$v_re2 <- df$v_re2 %>% as.numeric()
```

### Reproduce the pooled SMD
#### MA model 1
```{r}
ma1 <- metagen(TE = smd_re1,
              seTE = sqrt(v_re1),
              studlab = id_comparison,
              data = df,
              sm = "SMD",
              fixed = FALSE,
              random = TRUE, # a random effects MA
              method.tau = "DL", # DerSimonian-Laird estimator
                 )
windowsFonts(A = windowsFont("Times New Roman"))

png("figures/fig4_mam1.png", units = "in", width = 7.2, height = 6, res = 300)
forest.meta(ma1,
           fontfamily = "A",
           print.tau2 = TRUE,
           leftlabs = c("SMD No.", "d", "SE"))
```

#### MA model 2
```{r}
ma2 <- metagen(TE = smd_re2,
              seTE = sqrt(v_re2),
              studlab = id_comparison,
              data = df,
              sm = "SMD",
              fixed = FALSE,
              random = TRUE, # a random effects MA
              method.tau = "DL", # DerSimonian-Laird estimator
                 )
png("figures/fig4_mam2.png", units = "in", width = 7.2, height = 6, res = 300)
forest.meta(ma2,
           fontfamily = "A",
           print.tau2 = TRUE,
           leftlabs = c("SMD No.", "d", "SE"))
```

#### MA model 3
```{r}
ma3 <- metagen(TE = smd_ma,
              seTE = se_ma,
              studlab = id_comparison,
              data = df,
              sm = "SMD",
              fixed = FALSE,
              random = TRUE, # a random effects MA
              method.tau = "DL", # DerSimonian-Laird estimator
                 )
png("figures/fig4_mam3.png", units = "in", width = 7.2, height = 6, res = 300)
forest.meta(ma3,
           fontfamily = "A",
           print.tau2 = TRUE,
           leftlabs = c("SMD No.", "d", "SE"))
```


## Publication bias analysis

### PET-PEESE
#### Collate the necessary variables
For the PET-PEESE model, the effect sizes (here SMDs), their SEs, their variances, and their inverse-variance weights, are needed.
```{r}
petpeese <- data.frame(smd = df$smd_ma) # smds
petpeese$v <- df$se_ma^2 # within-study variances (extracted from the figures)
petpeese$se <- df$se_ma # standard errors of SMD estimates
petpeese$w <- 1/petpeese$v # inverse variance weights
```

#### PET (precision-effect test)
```{r}
pet <- lm(smd ~ se, weights = w, data = petpeese)
summary(pet)$coefficients
```

#### PEESE (precision-effect estimate with standard error)
```{r}
peese <- lm(smd ~ v, weights = w, data = petpeese)
summary(peese)$coefficients
```


### P-Curve

#### P-Curve
```{r}
pcurve(ma3, 
       effect.estimation = TRUE,
       N = df$nt_ma + df$nc_ma, 
       dmin = 0,
       dmax = 1)
```



### Three-parameter selection model
#### Create a `metafor` package meta-analysis object, necessary for the `selmodel` function
```{r}
ma3_metafor <- rma(yi = smd_ma,        
          sei = se_ma,
          data = df,
          method = "DL")
```

#### Fit the selection model
```{r}
selmodel(ma3_metafor,
         type = "stepfun",
         steps = 0.025)
```



## Outlier/influence diagnostics
### Leave-one-out analysis
```{r}
metainf(ma3, pooled = "random")
```


### Some plots
#### Baujat 
```{r}
outl <- InfluenceAnalysis(ma3, random = TRUE, text.scale = 2)
png("figures/fig7.png", units = "in", width = 5, height = 5, res = 300)
plot(outl, "baujat")
```

#### Forest plot
```{r}
plot(outl, "ES")
```
### Run meta-analysis without outliers
```{r}
s <- update.meta(ma1, subset = -c(8, 9, 11, 19))
forest.meta(s,

            print.tau2 = TRUE,
            leftlabs = c("SMD No.", "d", "SE"))
```

# Meta-analysis 3

## Reproducibility

### Load dataset & preprocess data
```{r}
df <- read_excel("data_thesis/Data_ps_raw_updated.xlsx", sheet = "MA3")

# make values numeric
df <- df %>% mutate_at(vars(starts_with('sd')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('mt')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('mc')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('smd')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('n')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('ci')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('p_')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('t_')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('F_')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('si')), as.numeric)
```

```{r}
# average group sample size
mean((df$nc_ma + df$nt_ma) / 2, na.rm = TRUE)
```

### Reproduce primary SMDs
This MA only included RCTs. 1 out of the 6 studies included was a conference abstract which only reported the total sample size. The 5 others reported group sample sizes, 3 reported raw means and SDs, one reported a potentially usable $t$-value. Hedges' $g$ was used. 
#### Studies which reported means and SDs
```{r}
df <- compute_dgs(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")

# relocate to facilitate inspection
df <- df %>% relocate(c(id_comparison, g, smd_ma), .after = dv_ps)
```
SMD 4 was reproduced. SMD 2 was approximated but in the other direction. SMD 5 quite close. Data extraction will be double-checked.

#### Studies which did not report means and/or SDs
```{r}
t_to_d(df$t_ps[[6]], df$nt_ps[[6]], df$nc_ps[[6]])[1]
```
Nope.





### Reproduce primary SMDs -- post double-checking data-extraction for irreproducible SMDs
1. 
```{r}
df$d <- p_to_d2(0.01, df$nt_ps[[1]], df$nc_ps[[1]])[1]
df$vd <- p_to_d2(0.01, df$nt_ps[[1]], df$nc_ps[[1]])[2]
compute_gs(d, vd, nt_ps, nc_ps, df)$g[1]
```

2. 
```{r}
compute_dgs(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$g
```
```{r}
compute_dgs(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[2,], denom = "pooled.sd")$g
```

```{r}
df$mt_ps.3 <- (df$mt_ps.1 + df$mt_ps.2) / 2
df$sdt_ps.3 <- (df$sdt_ps.1 + df$sdt_ps.2) / 2

compute_dgs(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$g
```

```{r}
df$mt_ps.3[[2]] <- (df$mt_ps.1[[2]] + df$mt_ps.2[[2]]) / 2
df$sdt_ps.3[[2]] <- (df$sdt_ps.1[[2]] + df$sdt_ps.2[[2]]) / 2

compute_dgs(nt_ps*2, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$g
```

```{r}
compute_dgs(nt_ps*2, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$g
```

```{r}
compute_dgs(nt_ps*2, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[2,], denom = "pooled.sd")$g
```

3.
```{r}
df$d <- p_to_d2(0.01, df$n_ps[[3]], df$n_ps[[3]])[1]
df$vd <- p_to_d2(0.01, df$n_ps[[3]], df$n_ps[[3]])[2]
compute_gs(d, vd, n_ps, n_ps, df)$g[3]
```

5.based on second set
```{r}
compute_dgs(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[5,], denom = "pooled.sd")$g
```
nope

take average
```{r}
df$mc_ps.3 <- (df$mc_ps.1 + df$mc_ps.2) / 2
df$mt_ps.3 <- (df$mt_ps.1 + df$mt_ps.2) / 2
df$sdc_ps.3 <- (df$sdc_ps.1 + df$sdc_ps.2) / 2
df$sdt_ps.3 <- (df$sdt_ps.1 + df$sdt_ps.2) / 2
compute_dgs(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.3, sdc_ps.3, data = df[5,], denom = "pooled.sd")$g
```
yup

6.
```{r}
df$d <- p_to_d2(0.169, df$nc_ps[[6]], df$nt_ps[[6]])[1]
df$vd <- p_to_d2(0.169, df$nc_ps[[6]], df$nt_ps[[6]])[2]
compute_gs(d, vd, nt_ps, nc_ps, df)$g[6]
```
yup

Overview of the results of double-checking data extraction for each of the 20 primary SMDs:
1. SMD 1 could be reproduced using a $p$ value (given as a range <0.01) for the comparison between the control and treatment medians at post. It will be used for MMA2.----- 3
2. Best approximated by taking the first set of means and SDs (SMA) and doubling the sample size for the treatment group (USED FOR MMA2). It was negative because the variable is reaction times. The variation without doubling the sample size and by averaging the two sets will be used for MMA 1 since it corresponds to other reproducible SMDs. ----- 2, 3
3. Same as 1 -------- 3
4. reproducible based on means and SDs of change percentages from pre to post -------- 3
5. SMD 5 was approximated well by averaging sets 1 and 2 and computing the SMD based on the averaged values. ------ 1
6. SMD 6 could be reproduced using a $p$ value for the comparison between the control and treatment mean change from baseline. ----- 3


### Collate reproduced primary SMDs for MA model 1
```{r}
# 1
df$smd_re1[[1]] <- NA

# 2

df$mt_ps.3 <- (df$mt_ps.1 + df$mt_ps.2) / 2
df$sdt_ps.3 <- (df$sdt_ps.1 + df$sdt_ps.2) / 2
df$smd_re1[[2]] <- compute_dgs(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$g %>% abs()

# 3
df$smd_re1[[3]] <- NA

# 4
df$smd_re1[[4]] <- NA

#5 
df$mc_ps.3 <- (df$mc_ps.1 + df$mc_ps.2) / 2
df$mt_ps.3 <- (df$mt_ps.1 + df$mt_ps.2) / 2
df$sdc_ps.3 <- (df$sdc_ps.1 + df$sdc_ps.2) / 2
df$sdt_ps.3 <- (df$sdt_ps.1 + df$sdt_ps.2) / 2
df$smd_re1[[5]] <- compute_dgs(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.3, sdc_ps.3, data = df[5,], denom = "pooled.sd")$g

#6
df$smd_re1[[6]] <- NA

# make numeric
df <- df %>% mutate_at(vars(starts_with('smd')), as.numeric)

# relocate to facilitate inspection
df <- df %>% relocate(c(smd_re1, smd_ma, id_comparison),  .after = dv_ps)
```



### Collate reproduced primary SMDs for MA model 2
```{r}
# 1
df$d <- p_to_d2(df$p_ps[[1]], df$nt_ps[[1]], df$nc_ps[[1]])[1]
df$vd <- p_to_d2(df$p_ps[[1]], df$nt_ps[[1]], df$nc_ps[[1]])[2]
df$smd_re2[[1]] <- compute_gs(d, vd, nt_ps, nc_ps, df)$g[1]

# 2
df$smd_re2[[2]] <- compute_dgs(nt_ps*2, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$g %>% abs()

# 3
df$d <- p_to_d2(df$p_ps[[3]], df$n_ps[[3]], df$n_ps[[3]])[1]
df$vd <- p_to_d2(df$p_ps[[3]], df$n_ps[[3]], df$n_ps[[3]])[2]
df$smd_re2[[3]] <- compute_gs(d, vd, n_ps, n_ps, df)$g[3]

# 4
df$smd_re2[[4]] <- compute_dgs(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[4,], denom = "pooled.sd")$g

#5 
df$mc_ps.3 <- (df$mc_ps.1 + df$mc_ps.2) / 2
df$mt_ps.3 <- (df$mt_ps.1 + df$mt_ps.2) / 2
df$sdc_ps.3 <- (df$sdc_ps.1 + df$sdc_ps.2) / 2
df$sdt_ps.3 <- (df$sdt_ps.1 + df$sdt_ps.2) / 2
df$smd_re2[[5]] <- compute_dgs(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.3, sdc_ps.3, data = df[5,], denom = "pooled.sd")$g

#6
df$d <- p_to_d2(df$p_ps[[6]], df$nc_ps[[6]], df$nt_ps[[6]])[1]
df$vd <- p_to_d2(df$p_ps[[6]], df$nc_ps[[6]], df$nt_ps[[6]])[2]
df$smd_re2[[6]] <- compute_gs(d, vd, nt_ps, nc_ps, df)$g[6]

# make numeric
df <- df %>% mutate_at(vars(starts_with('smd')), as.numeric)

# relocate to facilitate inspection
df <- df %>% relocate(smd_re2,  .after = smd_re1)
```


### Reproduce variances of the primary SMDs for MA model 1
```{r}
# 1
df$v_re1[[1]] <- NA

# 2
df$v_re1[[2]] <- compute_dgs(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$var.g

# 3
df$v_re1[[3]] <- NA

# 4
df$v_re1[[4]] <- NA

#5 
df$mc_ps.3 <- (df$mc_ps.1 + df$mc_ps.2) / 2
df$mt_ps.3 <- (df$mt_ps.1 + df$mt_ps.2) / 2
df$sdc_ps.3 <- (df$sdc_ps.1 + df$sdc_ps.2) / 2
df$sdt_ps.3 <- (df$sdt_ps.1 + df$sdt_ps.2) / 2
df$v_re1[[5]] <- compute_dgs(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.3, sdc_ps.3, data = df[5,], denom = "pooled.sd")$var.g

#6
df$v_re1[[6]] <- NA
```



### Reproduce variances of the primary SMDs for MA model 2
```{r}
# 1
df$d <- p_to_d2(0.01, df$nt_ps[[1]], df$nc_ps[[1]])[1]
df$vd <- p_to_d2(0.01, df$nt_ps[[1]], df$nc_ps[[1]])[2]
df$v_re2[[1]] <- compute_gs(d, vd, nt_ps, nc_ps, df)$var.g[1]

# 2
df$v_re2[[2]] <- compute_dgs(nt_ps*2, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$var.g

# 3
df$d <- p_to_d2(0.01, df$n_ps[[3]], df$n_ps[[3]])[1]
df$vd <- p_to_d2(0.01, df$n_ps[[3]], df$n_ps[[3]])[2]
df$v_re2[[3]] <- compute_gs(d, vd, n_ps, n_ps, df)$var.g[3]

# 4
df$v_re2[[4]] <- compute_dgs(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[4,], denom = "pooled.sd")$var.g

#5 
df$mc_ps.3 <- (df$mc_ps.1 + df$mc_ps.2) / 2
df$mt_ps.3 <- (df$mt_ps.1 + df$mt_ps.2) / 2
df$sdc_ps.3 <- (df$sdc_ps.1 + df$sdc_ps.2) / 2
df$sdt_ps.3 <- (df$sdt_ps.1 + df$sdt_ps.2) / 2
df$v_re2[[5]] <- compute_dgs(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.3, sdc_ps.3, data = df[5,], denom = "pooled.sd")$var.g

#6
df$d <- p_to_d2(0.169, df$nc_ps[[6]], df$nt_ps[[6]])[1]
df$vd <- p_to_d2(0.169, df$nc_ps[[6]], df$nt_ps[[6]])[2]
df$v_re2[[6]] <- compute_gs(d, vd, nt_ps, nc_ps, df)$var.g[6]

# make numeric
df <- df %>% mutate_at(vars(starts_with('v_')), as.numeric)
```


### Compute sampling variances and SEs based on the reported CIs

```{r}
df$v_ma <- ((df$ciu_ma - df$smd_ma) / 1.96)^2
df$se_ma <- ((df$ciu_ma - df$smd_ma) / 1.96)

# compare with reproduced variances
df <- df %>% relocate(c(v_re1, v_re2, v_ma), .after = smd_ma)
```


### Reproduce the pooled SMD
#### MA model 1
```{r}
ma1 <- metagen(TE = smd_re1,
              seTE = sqrt(v_re1),
              studlab = id_comparison,
              data = df,
              sm = "SMD",
              fixed = FALSE,
              random = TRUE, # a random effects MA
              method.tau = "DL", # DerSimonian-Laird estimator
                 )
windowsFonts(A = windowsFont("Times New Roman"))

png("figures/fig5_mam1.png", units = "in", width = 7.2, height = 3, res = 300)
forest.meta(ma1,
           fontfamily = "A",
           print.tau2 = TRUE,
           leftlabs = c("SMD No.", "g", "SE"))
```

#### MA model 2
```{r}
ma2 <- metagen(TE = smd_re2,
              seTE = sqrt(v_re2),
              studlab = id_comparison,
              data = df,
              sm = "SMD",
              fixed = FALSE,
              random = TRUE, # a random effects MA
              method.tau = "DL", # DerSimonian-Laird estimator
                 )
png("figures/fig5_mam2.png", units = "in", width = 7.2, height = 3, res = 300)
forest.meta(ma2,
           fontfamily = "A",
           print.tau2 = TRUE,
           leftlabs = c("SMD No.", "g", "SE"))
```

#### MA model 3
```{r}
ma3 <- metagen(TE = smd_ma,
              seTE = se_ma,
              studlab = as.character(id_comparison),
              data = df,
              sm = "SMD",
              fixed = FALSE,
              random = TRUE, # a random effects MA
              method.tau = "DL", # DerSimonian-Laird estimator
                 )
png("figures/fig5_mam3.png", units = "in", width = 7.2, height = 3, res = 300)
forest.meta(ma3,
           fontfamily = "A",
           print.tau2 = TRUE,
           leftlabs = c("SMD No.", "g", "SE"))
```

## Publication bias analysis

### PET-PEESE
#### Collate the necessary variables
For the PET-PEESE model, the effect sizes (here SMDs), their SEs, their variances, and their inverse-variance weights, are needed.
```{r}
petpeese <- data.frame(smd = df$smd_ma) # smds
petpeese$v <- df$v_ma # within-study variances (extracted from the figures)
petpeese$se <- df$se_ma # standard errors of SMD estimates
petpeese$w <- 1/petpeese$v # inverse variance weights
```

#### PET (precision-effect test)
```{r}
pet <- lm(smd ~ se, weights = w, data = petpeese)
summary(pet)$coefficients
```

#### PEESE (precision-effect estimate with standard error)
```{r}
peese <- lm(smd ~ v, weights = w, data = petpeese)
summary(peese)$coefficients
```


### P-Curve

#### P-Curve
```{r}
pcurve(ma3, 
       effect.estimation = TRUE,
       N = df$nt_ma + df$nc_ma, 
       dmin = 0,
       dmax = 1)
```



### Three-parameter selection model
#### Create a `metafor` package meta-analysis object, necessary for the `selmodel` function
```{r}
ma3_metafor <- rma(yi = smd_ma,        
          sei = se_ma,
          data = df,
          method = "DL")
```

#### Fit the selection model
```{r}
selmodel(ma3_metafor,
         type = "stepfun",
         steps = 0.025)
```



## Outlier/influence diagnostics
### Leave-one-out analysis
```{r}
metainf(ma3, pooled = "random")
```


### Some plots
#### Baujat 
```{r}
outl <- InfluenceAnalysis(ma3, random = TRUE, text.scale = 2)
png("figures/fig8.png", units = "in", width = 5, height = 5, res = 300)
plot(outl, "baujat")
```

#### Forest plot
```{r}
plot(outl, "ES")
```

### Run meta-analysis without outliers
```{r}
s <- update.meta(ma3, subset = -c(2))
forest.meta(s,

            print.tau2 = TRUE,
            leftlabs = c("SMD No.", "g", "SE"))
```

