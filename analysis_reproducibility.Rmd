---
title: Data analysis notebook / reproducibility report
output:
  html_document:
    number_sections: true
    toc: true
    toc_depth: 3
    toc_float: true
---

**Load packages and dataset**
```{r setup, echo = FALSE}
knitr::opts_chunk$set(
	message = FALSE,
	warning = FALSE,
	include = TRUE
)
# options(scipen = 999, digits = 2)
```

```{css, echo = FALSE}
body {
  counter-reset: counter-rchunks;
}

div.main-container {
  padding-left: 3.5em;
}

pre.r {
  counter-increment: counter-rchunks;
  position: relative;
  overflow: visible;
}

pre.r::before {
  content: '[' counter(counter-rchunks) ']:';
  display: inline-block;
  position: absolute;
  left: -3.5em;
  color: rgb(48, 63, 159);
}

/* Whole document: */
body{
  font-family: Calibri;
  font-size: 11pt;
}
/* Headers */
h1{
  font-size: 18pt;
  text-align: center;
  font-weight: bold
}
h2{
  font-size: 16.5pt;
  text-indent: 2em
}
h3{
  font-size: 14pt;
  text-indent: 4em
}
h4{
  font-size: 12.5pt;
  text-indent: 6em
}
```


```{r}
library("readxl") 
library("tidyverse")
library("metafor")
library("MAd")
library("meta")
library("dmetar") # not available on CRAN as of Nov 2023, pulled from GitHub: https://dmetar.protectlab.org/

```

If you want to run the code outside of the project folder and without the renv.lock file (from the [`renv`](https://rstudio.github.io/renv/articles/renv.html) package), loading the packages using the package [`groundhog`](https://groundhogr.com/) would ensure the code's long term reproducibility:
```{r}
# install.packages("groundhog")
# library(groundhog)
# pkgs <- c("readxl", "tidyverse", "metafor", "MAd", "meta")
# date = "2021-12-19"
# groundhog.library(pkgs, date)
```


# Meta-analysis 1

### Load dataset & preprocess data - FINAL
```{r}
df <- read_excel("data_thesis/Data_ps_raw.xlsx", sheet = "MA1")


# remove characters marking SEs, upper bounds of SE bars, or upper bounds of CIs, to convert to SDs
df[] <- lapply(df, gsub, pattern = '/', replacement = '', fixed = TRUE)
df[] <- lapply(df, gsub, pattern = '*', replacement = '', fixed = TRUE)

# make values numeric
df <- df %>% mutate_at(vars(starts_with('sd')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('mt')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('mc')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('smd')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('n')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('ci')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('p_')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('t_')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('F_')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('se')), as.numeric)

# Convert SEs to SDs
df[3, "sdc_ps.1"] <- df[3, "sdc_ps.1"] * sqrt(10)
df[3, "sdt_ps.1"] <- df[3, "sdt_ps.1"] * sqrt(10)

# Convert upper bounds of SE bars extracted from figures to SDs
df[1, "sdc_ps.1"] <- (df[1, "sdc_ps.1"] - df[1, "mc_ps.1"]) * sqrt(7)
df[1, "sdt_ps.1"] <- (df[1, "sdt_ps.1"] - df[1, "mt_ps.1"]) * sqrt(7)

df[2, "sdc_ps.1"] <- (df[2, "sdc_ps.1"] - df[2, "mc_ps.1"]) * sqrt(9)
df[2, "sdt_ps.1"] <- (df[2, "sdt_ps.1"] - df[2, "mt_ps.1"]) * sqrt(9)

df[8, "sdc_ps.1"] <- (df[8, "sdc_ps.1"] - df[8, "mc_ps.1"]) * sqrt(13)
df[8, "sdt_ps.1"] <- (df[8, "sdt_ps.1"] - df[8, "mt_ps.1"]) * sqrt(14)

df[9, "sdc_ps.1"] <- (df[9, "sdc_ps.1"] - df[9, "mc_ps.1"]) * sqrt(13)
df[9, "sdt_ps.1"] <- (df[9, "sdt_ps.1"] - df[9, "mt_ps.1"]) * sqrt(13)

df[10, "sdc_ps.1"] <- (df[10, "sdc_ps.1"] - df[10, "mc_ps.1"]) * sqrt(7)
df[10, "sdt_ps.1"] <- (df[10, "sdt_ps.1"] - df[10, "mt_ps.1"]) * sqrt(6)

df[11, "sdc_ps.1"] <- (df[11, "sdc_ps.1"] - df[11, "mc_ps.1"]) * sqrt(7)
df[11, "sdt_ps.1"] <- (df[11, "sdt_ps.1"] - df[11, "mt_ps.1"]) * sqrt(5)

# Convert upper bounds of SD bars extracted from figures to SDs
df[4, "sdc_ps.1"] <- (df[4, "sdc_ps.1"] - df[4, "mc_ps.1"])
df[4, "sdt_ps.1"] <- (df[4, "sdt_ps.1"] - df[4, "mt_ps.1"])

# Convert upper bounds of CI bars extracted from figures to SDs
df[20, "sdc_ps.1"] <- (df[20, "sdc_ps.1"] - df[20, "mc_ps.1"]) * sqrt(45) / 1.96
df[20, "sdt_ps.1"] <- (df[20, "sdt_ps.1"] - df[20, "mt_ps.1"]) * sqrt(45) / 1.96
```

```{r}
# average group sample size
mean((df$nc_ma + df$nt_ma) / 2)
```



### Reproduce primary SMDs
3 meta-analytic models were fit:

1. MA1: Using the SMDs reproduced strictly following information given in the meta-analysis or a standard procedure apparently adopted for at least 2 other primary SMDs (e.g., Cohenâ€™s $d$ of tDCS vs. Sham at post intervention).
2. MA2: Using the SMDs reproduced strictly following information given in the meta-analysis or a standard procedure apparently adopted for at least 2 other primary SMDs + SMDs that could be successfully reproduced (i.e., reproduced SMD = reported SMD) following a procedure which __either__ does not entirely correspond to what the meta-analysts report having adopted __or__ does not (necessarily) produce an SMD that is comparable to what would result from following the procedure apparently adopted for at least 2 other primary SMDs
3. MA3: Using the reported SMDs only (reproduce fitting the MA model using values reported in the MA only)

#### Between-groups studies which reported sample sizes, means and SDs (SEs/CIs)
```{r}
df <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")
df$d <- abs(df$d)

# relocate to facilitate inspection
df <- df %>% relocate(c(id_comparison, d, smd_ma), .after = dv_ps)
```
The SMDs that could not be reproduced or approximated (those based on values from figures can only be approximated due to variations in how values were extracted from figures):  (4/17 comparisons from between-groups studies). 
Reproduced SMDs 16, 17, 18, and 20 deviate from the reported ones beyond what would be expected as a result of rounding or differences in how values were extracted from figures. For SMDs 16 and 20, other values could have been used:

For SMD 16, another set of means and SDs could have been used:
```{r}
compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[16]]
```
Reproduces reported SMD successfully.

SMD 20 had corresponding $p$-value:
```{r}
p_to_d1(df$p_ps[[20]], df$nt_ps[[20]], df$nc_ps[[20]])[1]
p_to_d2(df$p_ps[[20]], df$nt_ps[[20]], df$nc_ps[[20]])[1]
```


The SMD based on the two tailed $p$ value successfully reproduces the reported SMD.

#### Crossover studies which reported sample sizes, means and SDs (SEs/CIs)
Since the meta-analysts listed the sample size of both the treatment and control group as = $N$ = the number of participants, I use N as the sample size of both groups even though there aren't two groups:
```{r}
df2 <- df %>% filter(is.na(nc_ps))
df2 <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df2, denom = "pooled.sd")
```
Reproduced SMDs 12, 13, 21 deviate from the reported ones beyond what would be expected as a result of rounding or differences in how values were extracted from figures. For SMDs 12 and 13, other values could have been used:
SMDs 12 and 13 had another set of means and SDs:
```{r}
compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[12]]
compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[13]]
```
Still not reproducible. SMD 13 does reproduce the Cohen's $d$ reported in the primary study, though. 

### Overview of SMDs post double checking irreproducible SMDs
Data extraction was correct for all SMDs and no further data were extracted (see data sheets column "comments" for sources of data).

1. successfully reproduced
2. approximated 
3. successfully reproduced
4. approximated
5. successfully reproduced
6. successfully reproduced
7. successfully reproduced
8. irreproducible
9. irreproducible
10. approximated
11. approximated
12. irreproducible. SMD based on the first set of means and SDs will be used for MA model 2  (according to definition above) since the control values here are the baseline (0) values which corresponds more or less to the meta-analysts' description of their procedure "baseline: Ctrl".
13. irreproducible. SMD based on the first set will be used for MA model 2 since the control values here are the baseline (0) values which corresponds more or less to the meta-analysts' description of their procedure "baseline: Ctrl".
14. successfully reproduced
15. approximated
16. irreproducible using the values purported to have been used by the meta-analysts "3J-ROM(ctDCS on cH during OT at retention: Rx vs sham during OT at retention: Ctrl)", successfully reproduced using "Proportional change in 3J-ROM" values. The SMD based on the latter values will be used for MA model 2 .
17. irreproducible. 
18. irreproducible.
19. successfully reproduced but not according to the information given in the MA. the values used are for changes in JHFT time from baseline whereas the meta-analysts report using "Time in JHFT".
20. successfully reproduced using a $p$-value based on differences in medians. will be used for  MA model 2.
21. irreproducible.

### Collate reproduced primary SMDs for MA model 1
```{r}
# SMDs which were successfully reproduced using the first set of means and SDs, in accordance with information in MA
df$smd_re1 <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$d

df$smd_re1[[2]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$d[[2]]

# SMDs which could not be reproduced using the first set of means and SDs, in accordance with information in MA
df$smd_re1[[21]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$d[[21]]

# SMDs which were successfully reproduced using values that either do not quite correspond to the information given in the MA or the standard method adopted for the other SMDs

df$smd_re1[[19]] <- NA

df$smd_re1[[20]] <- NA

# SMDs which could not be reproduced using values that either do not quite correspond to the information given in the MA or the standard method adopted for the other SMDs
df$smd_re1[[12]] <- NA

df$smd_re1[[13]] <- NA
  
# make numeric and positive
df$smd_re1 <- df$smd_re1 %>% as.numeric() %>% abs()

# relocate to check if everything's fine
df <- df %>% relocate(c(id_comparison, smd_re1, smd_ma), .after = dv_ps)
```


### Collate reproduced primary SMDs for MA model 2
```{r}
# SMDs which were successfully reproduced using the first set of means and SDs, in accordance with information in MA
df$smd_re2 <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$d

df$smd_re2[[2]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$d[[2]]

# SMDs which could not be reproduced using the first set of means and SDs, in accordance with information in MA
df$smd_re2[[21]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$d[[21]]

# SMDs which were successfully reproduced using values that either do not quite correspond to the information given in the MA or the standard method adopted for the other SMDs
df$smd_re2[[16]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[16]]

df$smd_re2[[19]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$d[[19]]

df$smd_re2[[20]] <- p_to_d2(df$p_ps[[20]], df$nt_ps[[20]], df$nc_ps[[20]])[1]

# SMDs which could not be reproduced using values that either do not quite correspond to the information given in the MA or the standard method adopted for the other SMDs
df$smd_re2[[12]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$d[[12]]

df$smd_re2[[13]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$d[[13]]
  
# make numeric and positive
df$smd_re2 <- df$smd_re2 %>% as.numeric() %>% abs()

# relocate to check if everything's fine
df <- df %>% relocate(smd_re2, .after = smd_re1)
```

### Proportion of successfully reproduced primary SMDs strictly following information given in the MA
#### reproducible to the second decimal place
```{r}
df <- transform(df, rep_1_sec_dec = ifelse(round(smd_re1, digits = 2) == smd_ma, 1, 0))
sum(df$irrep_1_sec_dec, na.rm = TRUE)
sum(df$irrep_1_sec_dec, na.rm = TRUE)/21 * 100
```
#### reproducible to the first decimal place
```{r}
df <- transform(df, rep_1_fir_dec = ifelse(round(smd_re1, digits = 1) == round(smd_ma, digits = 1), 1, 0))
sum(df$rep_1_fir_dec, na.rm = TRUE)
sum(df$rep_1_fir_dec, na.rm = TRUE)/21 * 100
```
### Proportion of successfully reproduced primary SMDs brute force
#### reproducible to the second decimal place
```{r}
df <- transform(df, rep_2_sec_dec = ifelse(round(smd_re2, digits = 2) == smd_ma, 1, 0))
sum(df$rep_2_sec_dec, na.rm = TRUE)
sum(df$rep_2_sec_dec, na.rm = TRUE)/21 * 100
```
#### reproducible to the first decimal place
```{r}
df <- transform(df, rep_2_fir_dec = ifelse(round(smd_re2, digits = 1) == round(smd_ma, digits = 1), 1, 0))
sum(df$rep_2_fir_dec, na.rm = TRUE)
sum(df$rep_2_fir_dec, na.rm = TRUE)/21 * 100

df <- df %>% relocate(c(id_comparison, rep_1_sec_dec, rep_2_sec_dec, rep_1_fir_dec, rep_2_fir_dec, smd_re1, smd_re2, smd_ma), .after = id_ps)
```



### Reproduce variances of the primary SMDs for MA model 1
`MAd`'s `compute_ds()` and `p_to_d1` functions automatically calculate the corresponding sampling/sampling variances. In cases where not enough data were available, the square of the standard error extracted from the funnel plot in the MA will be used.
```{r}
# SMDs which were successfully reproduced using the first set of means and SDs, in accordance with information in MA
df$v_re1 <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$var.d

df$v_re1[[2]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$var.d[[2]]

# SMDs which could not be reproduced using the first set of means and SDs, in accordance with information in MA
df$v_re1[[21]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$var.d[[21]]

# SMDs which were successfully reproduced using values that either do not quite correspond to the information given in the MA or the standard method adopted for the other SMDs
# df$v_re1[[16]] <- NA

df$v_re1[[19]] <- NA

df$v_re1[[20]] <- NA

# SMDs which could not be reproduced using values that either do not quite correspond to the information given in the MA or the standard method adopted for the other SMDs
df$v_re1[[12]] <- NA

df$v_re1[[13]] <- NA
  
# make numeric
df$v_re1 <- as.numeric(df$v_re1)

# relocate to check if everything's fine
df$v_ma <- df$se_ma^2
df <- df %>% relocate(c(id_comparison, v_re1, v_ma), .after = dv_ps)
```


### Reproduce variances of the primary SMDs for MA model 2
```{r}
# SMDs which were successfully reproduced using the first set of means and SDs, in accordance with information in MA
df$v_re2 <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$var.d

df$v_re2[[2]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$var.d[[2]]

# SMDs which could not be reproduced using the first set of means and SDs, in accordance with information in MA
df$v_re2[[21]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$var.d[[21]]

# SMDs which were successfully reproduced using values that either do not quite correspond to the information given in the MA or the standard method adopted for the other SMDs
df$v_re2[[16]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$var.d[[16]]

df$v_re2[[19]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$var.d[[19]]

df$v_re2[[20]] <- p_to_d2(df$p_ps[[20]], df$nt_ps[[20]], df$nc_ps[[20]])[2]

# SMDs which could not be reproduced using values that either do not quite correspond to the information given in the MA or the standard method adopted for the other SMDs
df$v_re2[[12]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$var.d[[12]]

df$v_re2[[13]] <- df$smd_re2[[13]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")$var.d[[13]]

  
# make numeric
df$v_re2 <- as.numeric(df$v_re2)

# relocate to check if everything's fine
df$v_ma <- df$se_ma^2
df <- df %>% relocate(c(id_comparison, v_re2, v_ma), .after = dv_ps)
```

### Reproduce the pooled SMD
#### MA model 1
```{r}
ma1 <- metagen(TE = smd_re1,
              seTE = sqrt(v_re1),
              studlab = id_comparison,
              data = df,
              sm = "SMD",
              fixed = FALSE,
              random = TRUE, # a random effects MA
              method.tau = "DL", # DerSimonian-Laird estimator
                 )
windowsFonts(A = windowsFont("Times New Roman"))

png("figures/fig3_mam1.png", units = "in", width = 7.2, height = 6, res = 300)
forest.meta(ma1,
           fontfamily = "A",
           print.tau2 = TRUE,
           leftlabs = c("SMD No.", "d", "SE"))
```

#### MA model 2
```{r}
ma2 <- metagen(TE = smd_re2,
              seTE = sqrt(v_re2),
              studlab = id_comparison,
              data = df,
              sm = "SMD",
              fixed = FALSE,
              random = TRUE, # a random effects MA
              method.tau = "DL", # DerSimonian-Laird estimator
                 )
png("figures/fig3_mam2.png", units = "in", width = 7.2, height = 6, res = 300)
forest.meta(ma2,
           fontfamily = "A",
           print.tau2 = TRUE,
           leftlabs = c("SMD No.", "d", "SE"))
```

#### MA model 3
```{r}
ma3 <- metagen(TE = smd_ma,
              seTE = se_ma,
              studlab = id_comparison,
              data = df,
              sm = "SMD",
              fixed = FALSE,
              random = TRUE, # a random effects MA
              method.tau = "DL", # DerSimonian-Laird estimator
                 )
png("figures/fig3_mam3.png", units = "in", width = 7.2, height = 6, res = 300)
forest.meta(ma3,
           fontfamily = "A",
           print.tau2 = TRUE,
           leftlabs = c("SMD No.", "d", "SE"))
```


## Publication bias analysis
The analysis in this section mostly follows the tutorial [here](https://bookdown.org/MathiasHarrer/Doing_Meta_Analysis_in_R/pub-bias.html#addressing-pubbias).

### PET-PEESE
#### Collate the necessary variables
For the PET-PEESE model, the effect sizes (here SMDs), their SEs, their variances, and their inverse-variance weights, are needed.
```{r}
petpeese <- data.frame(smd = df$smd_ma) # smds
petpeese$v <- df$v_ma # sampling variances (extracted from the figures)
petpeese$se <- df$se_ma # standard errors of SMD estimates
petpeese$w <- 1/petpeese$v # inverse variance weights
```

#### PET (precision-effect test)
```{r}
pet <- lm(smd ~ se, weights = w, data = petpeese)
summary(pet)$coefficients
```

#### PEESE (precision-effect estimate with standard error)
```{r}
peese <- lm(smd ~ v, weights = w, data = petpeese)
summary(peese)$coefficients
```
Both estimates indicate the presence of publication bias.


### P-Curve

#### P-Curve
```{r}
pcurve(ma3, 
       effect.estimation = TRUE,
       N = df$nt_ma + df$nc_ma, 
       dmin = 0,
       dmax = 1)
```
No indication of bias.


### Three-parameter selection model
#### Create a `metafor` package meta-analysis object, necessary for the `selmodel` function
```{r}
ma3_metafor <- rma(yi = smd_ma,        
          sei = se_ma,
          data = df,
          method = "DL")
```

#### Fit the selection model
```{r}
selmodel(ma3_metafor,
         type = "stepfun",
         steps = 0.025)
```
No indication of bias.


## Outlier/influence diagnostics
### Leave-one-out analysis
```{r}
metainf(ma3, pooled = "random")
```
Removing SMD 8 would reduce the pooled SMD by ~ 0.05 and considerably reduce the variance.

### Some plots
#### Baujat 
```{r}
outl <- InfluenceAnalysis(ma3, random = TRUE, text.scale = 2)
png("figures/fig6.png", units = "in", width = 5, height = 5, res = 300)
plot(outl, "baujat")
```

#### Forest plot
```{r}
plot(outl, "ES")
```


SMDs 6, 7, and 8 contribute disproportionately to both the variance and the pooled SMD.

### Run meta-analysis without outliers
```{r}
s <- update.meta(ma3, subset = -c(6, 7, 8))
forest.meta(s,

            print.tau2 = TRUE,
            leftlabs = c("SMD No.", "d", "SE"))
```
Removing the outliers increases the pooled SMD by ~ 0.7 and eliminates between-study heterogeneity altogether.

# Meta-analysis 2

## Reproducibility

### Load dataset & preprocess data
```{r}
df <- read_excel("data_thesis/Data_ps_raw.xlsx", sheet = "MA2")


# remove characters marking SEs, upper bounds of SE bars, or upper bounds of CIs, to convert to SDs
df[] <- lapply(df, gsub, pattern = '/', replacement = '', fixed = TRUE)
df[] <- lapply(df, gsub, pattern = '*', replacement = '', fixed = TRUE)

# make values numeric
df <- df %>% mutate_at(vars(starts_with('sd')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('mt')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('mc')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('smd')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('n')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('ci')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('p_')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('t_')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('F_')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('se')), as.numeric)

# Convert upper bounds of SE bars extracted from figures to SDs
df[10, "sdc_ps.1"] <- (df[10, "sdc_ps.1"] - df[10, "mc_ps.1"]) * sqrt(13)
df[10, "sdt_ps.1"] <- (df[10, "sdt_ps.1"] - df[10, "mt_ps.1"]) * sqrt(13)

df[11, "sdc_ps.1"] <- (df[11, "sdc_ps.1"] - df[11, "mc_ps.1"]) * sqrt(13)
df[11, "sdt_ps.1"] <- (df[11, "sdt_ps.1"] - df[11, "mt_ps.1"]) * sqrt(13)

df[12, "sdc_ps.1"] <- (df[12, "sdc_ps.1"] - df[12, "mc_ps.1"]) * sqrt(6)
df[12, "sdt_ps.1"] <- (df[12, "sdt_ps.1"] - df[12, "mt_ps.1"]) * sqrt(7)

df[18, "sdc_ps.1"] <- (df[18, "sdc_ps.1"] - df[18, "mc_ps.1"]) * sqrt(13)


# Convert lower bounds of SE bars extracted from figures to SDs
df[13, "sdc_ps.1"] <- (df[13, "sdc_ps.1"] + df[13, "mc_ps.1"]) * sqrt(25)
df[13, "sdt_ps.1"] <- (df[13, "sdt_ps.1"] + df[13, "mt_ps.1"]) * sqrt(25)

df[18, "sdt_ps.1"] <- (df[18, "sdt_ps.1"] + df[18, "mt_ps.1"]) * sqrt(13)
```

```{r}
# average group sample size
mean((df$nc_ma + df$nt_ma) / 2)
```

### Reproduce primary SMDs
#### Between-groups studies which reported sample sizes, means and SDs (SEs/CIs)
```{r}
#df <- compute_dgs(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")
# relocate to facilitate inspection
#df <- df %>% relocate(c(d, g, smd_ma), .after = dv_ps)
```

For PSs that reported means and SDs (no extraction from figure necessary), all reported SMDs were approximated better by Cohen's $d$s than Hedges' $g$s. I will thus assume the authors used Cohen's $d$s:

```{r}
df <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")

# relocate to facilitate inspection
df <- df %>% relocate(c(id_comparison, d, smd_ma), .after = dv_ps)
```


Reproduced SMDs 6, 7, 9, 12, 14, 15 deviate from the reported ones beyond what would be expected as a result of rounding or differences in how values were extracted from figures. For SMDs 6, 7, 14, and 15, other values could have reasonably been used:

SMDs 6 and 7 had corresponding $p$-values:
```{r}
# one-tailed p-value + sample sizes to d
p_to_d1(0.925, 6, 5)[1]
p_to_d1(0.897, 6, 5)[1]

# two-tailed p-value + sample sizes to d
p_to_d2(0.925, 6, 5)[1]
p_to_d2(0.897, 6, 5)[1]
```
Since these are even further from the ones based on means and SDs, data extraction was double checked for correctness (see below).


For SMDs 14 and 15, two other sets of means and SDs could have been used:
```{r}
# Set 2
compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[14]]
compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[15]]

# Set 3
compute_ds(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.3, sdc_ps.3, data = df, denom = "pooled.sd")$d[[14]]
compute_ds(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.3, sdc_ps.3, data = df, denom = "pooled.sd")$d[[15]]
```
Values of set 2 are much closer, but not quite identical.


#### Crossover studies which reported sample sizes, means and SDs (SEs/CIs)
Since the meta-analysts listed the sample size of both the treatment and control group as = $N$ = the number of participants, I use N as the sample size of both groups even though there aren't two groups:
```{r}
df2 <- df %>% filter(is.na(nc_ps))
df2 <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df2, denom = "pooled.sd")
```
Reproduced SMDs 1, 2, 4, 5, 13, 20 deviate from the reported ones beyond what would be expected as a result of rounding or differences in how values were extracted from figures. For SMDs 1, 2, 4, 5, and 20, other values could have reasonably been used:

SMD 1 had two other sets of means and SDs and a corresponding $p$ value:
```{r}
# Set 2
compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[1]]


# Set 3
compute_ds(n_ps, mt_ps.3, sdt_ps.3, n_ps, mc_ps.3, sdc_ps.3, data = df, denom = "pooled.sd")$d[[1]]

# p-value
p_to_d1(df$p_ps[[1]], df$n_ps[[1]], df$n_ps[[1]])[1]
p_to_d2(df$p_ps[[1]], df$n_ps[[1]], df$n_ps[[1]])[1]
```
The $d$ based on the one-tailed $p$-values is closest.

SMD 2 had a corresponding $p$ value:
```{r}
p_to_d1(df$p_ps[[2]], df$n_ps[[2]], df$n_ps[[2]])[1]
p_to_d2(df$p_ps[[2]], df$n_ps[[2]], df$n_ps[[2]])[1]
```
Closer.

SMDs 4, 5, and 20 had another set of means and SDs:
```{r}
compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[4]]
compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[5]]
compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[20]]
```
Nope.

#### Studies which did not report means and/or SDs (SEs/CIs)
For SMD 8, only means were reported. Computing an SMD is thus not possible. For SMD 19 no means or SDs were reported but a potentially suitable $p$-value:
```{r}
p_to_d1(df$p_ps[[19]], df$n_ps[[19]], df$n_ps[[19]])[1]
p_to_d2(df$p_ps[[19]], df$n_ps[[19]], df$n_ps[[19]])[1]
```
The one-tailed one is close enough. 

For SMD 3, an SMD was reported in the primary study which was close to the one reported in the MA.


### Reproduce primary SMDs -- post double-checking data-extraction for irreproducible SMDs
Overview of the results of double-checking data extraction for each of the 20 primary SMDs:

1. Data extraction correct, primary SMD irreproducible. The SMD based on the $p$-value is closer to the reported one but will not be used for reproducing the pooled SMD because the $p$-value is for the comparison tDCS_post vs. tDCS_pre and not tDCS_post vs. sham_post (which is supposed to be the outcome). The SMD based on the second set of means and SDs will be used because it's closest to the reported one even though the means and SDs are raw and not "change in PPT".
2. Data extraction correct, primary SMD irreproducible. The SMD based on the $p$-value is closer to the reported one but will not be used for reproducing the pooled SMD because the $p$-value is for the comparison in the improvement from baseline between tDCS condition, not "JTT (sham vs. ctDCS at post)" (which is supposed to be the outcome). The reproduced SMD based on the means and SDs will be used for the pooled SMD.
3. The SMD reported in the primary study will be used to reproduce the pooled SMD. The SMD is for improvement of tDCS group from baseline ==> model 2
4. Data extraction correct, primary SMD irreproducible. The SMD based on the first set of means and SDs will be used because it's the percentage of change means and SDs, which is supposed to be the outcome used in the MA.
5. Data extraction correct, primary SMD irreproducible. The SMD based on the second set of means and SDs will be used because they are derived by separating the N = 9 into two groups n = 6 and 3, respectively, which is how the meta-analysts report having done it.
6. Since the means and SDs from the first set are for changes in the outcome and not raw, I extracted raw means and SDs from figures. SMDs based on these values will be used for the pooled SMD. The SMD is approximated
7. Since the means and SDs from the first set are for changes in the outcome and not raw, I extracted raw means and SDs from figures. SMDs based on these values will be used for the pooled SMD. The SMD is irreproducible.
8. successfully reproduced using a $p$ value for the comparison between the 3 groups cathodal, anodal and sham at post, will be used for MA model 2
9. Data extraction correct, primary SMD irreproducible. successfully reproduced using a $p$ value for the comparison between the 3 groups cathodal, anodal and sham at post, will be used for MA model 2
10. SMD can be considered as reproducible since the difference is probably due to variation in how the means and SDs were extracted from the figure. NOPE ACCORDING TO CLASSIFICATION SCHEME
11. Same as 10, but negative since the scale used is negatively coded.
12. I made a mistake in extracting sample sizes. The SMD remains irreproducible after correction.
13. Data extraction correct, primary SMD irreproducible.
14. Data extraction correct, primary SMD irreproducible. SMDs based on set 2 are closest to the reported SMDs but these are follow up values not post. Thus the values of the first set will be used for reproducing the pooled SMD.
15. Data extraction correct, primary SMD irreproducible. SMDs based on set 2 are closed to the reported SMDs but these are follow up values not post. Thus the values of the first set will be used for reproducing the pooled SMD.
16. Data extraction correct, primary SMD irreproducible. Almost the same as the reported SMD but negative.
17. Reproducible.
18. Same as 10, but negative since the variable is reaction time.
19. Approximated by using a $p$ value for tDCS vs. sham post comparison. Cathodal had a negative effect.
20. Data extraction correct, primary SMD irreproducible. SMD based on the second set of means and SDs will be used since it's the post values.


Reproduce SMDs 6 & 7 using values extracted from figures:
```{r}
# Convert upper bounds of SD bars extracted from figures to SDs
df[6, "sdc_ps.2"] <- (df[6, "sdc_ps.2"] - df[6, "mc_ps.2"])
df[6, "sdt_ps.2"] <- (df[6, "sdt_ps.2"] - df[6, "mt_ps.2"])

df[7, "sdc_ps.2"] <- (df[7, "sdc_ps.2"] - df[7, "mc_ps.2"])
df[7, "sdt_ps.2"] <- (df[7, "sdt_ps.2"] - df[7, "mt_ps.2"])

# Compute Cohen's ds
compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[6]]
compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df, denom = "pooled.sd")$d[[7]]
```


Reproduce SMDs 8 & 9 using $p$-values:
```{r}
p_to_d2(df$p_ps[[8]], df$nc_ps[[8]], df$nt_ps[[8]])[1]
p_to_d2(df$p_ps[[9]], df$nc_ps[[9]], df$nt_ps[[9]])[1]
```
### Collate reproduced primary SMDs for MA model 1
```{r}
df$smd_re1[[1]] <- NA

df$smd_re1[[2]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$d

df$smd_re1[[3]] <- NA

df$smd_re1[[4]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[4,], denom = "pooled.sd")$d

df$smd_re1[[5]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[5,], denom = "pooled.sd")$d

df$smd_re1[[6]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[6,], denom = "pooled.sd")$d

df$smd_re1[[7]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[7,], denom = "pooled.sd")$d

df$smd_re1[[8]] <- NA

df$smd_re1[[9]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[9,], denom = "pooled.sd")$d

df$smd_re1[[10]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[10,], denom = "pooled.sd")$d

df$smd_re1[[11]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[11,], denom = "pooled.sd")$d %>% abs()

df$smd_re1[[12]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[12,], denom = "pooled.sd")$d

df$smd_re1[[13]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[13,], denom = "pooled.sd")$d

df$smd_re1[[14]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[14,], denom = "pooled.sd")$d

df$smd_re1[[15]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[15,], denom = "pooled.sd")$d

df$smd_re1[[16]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[16,], denom = "pooled.sd")$d

df$smd_re1[[17]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[17,], denom = "pooled.sd")$d

df$smd_re1[[18]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[18,], denom = "pooled.sd")$d %>% abs()

df$smd_re1[[19]] <- -p_to_d1(df$p_ps[[19]], df$n_ps[[19]], df$n_ps[[19]])[1]

df$smd_re1[[20]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[20,], denom = "pooled.sd")$d

# make numeric
df$smd_re1 <- df$smd_re1 %>% as.numeric()

# relocate to check if everything's fine
df <- df %>% relocate(c(id_comparison, smd_re1, smd_ma), .after = dv_ps)
```




### Collate reproduced primary SMDs for MA model 2
```{r}
df$smd_re2[[1]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[1,], denom = "pooled.sd")$d

df$smd_re2[[2]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$d

df$smd_re2[[3]] <- df$smd_ps[[3]]

df$smd_re2[[4]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[4,], denom = "pooled.sd")$d

df$smd_re2[[5]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[5,], denom = "pooled.sd")$d

df$smd_re2[[6]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[6,], denom = "pooled.sd")$d

df$smd_re2[[7]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[7,], denom = "pooled.sd")$d

df$smd_re2[[8]] <- -p_to_d2(df$p_ps[[8]], df$nc_ps[[8]], df$nt_ps[[8]])[1]

df$smd_re2[[9]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[9,], denom = "pooled.sd")$d

df$smd_re2[[10]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[10,], denom = "pooled.sd")$d

df$smd_re2[[11]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[11,], denom = "pooled.sd")$d %>% abs()

df$smd_re2[[12]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[12,], denom = "pooled.sd")$d

df$smd_re2[[13]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[13,], denom = "pooled.sd")$d

df$smd_re2[[14]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[14,], denom = "pooled.sd")$d

df$smd_re2[[15]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[15,], denom = "pooled.sd")$d

df$smd_re2[[16]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[16,], denom = "pooled.sd")$d

df$smd_re2[[17]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[17,], denom = "pooled.sd")$d

df$smd_re2[[18]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[18,], denom = "pooled.sd")$d %>% abs()

df$smd_re2[[19]] <- -p_to_d1(df$p_ps[[19]], df$n_ps[[19]], df$n_ps[[19]])[1]

df$smd_re2[[20]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[20,], denom = "pooled.sd")$d

# make numeric
df$smd_re2 <- df$smd_re2 %>% as.numeric()

# relocate to check if everything's fine
df <- df %>% relocate(smd_re2, .after = smd_re1)
```


### Reproduce variances of the primary SMDs for MA model 1
```{r}
df$v_re1[[1]] <- NA

df$v_re1[[2]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$var.d

df$v_re1[[3]] <- NA

df$v_re1[[4]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[4,], denom = "pooled.sd")$var.d

df$v_re1[[5]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[5,], denom = "pooled.sd")$var.d

df$v_re1[[6]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[6,], denom = "pooled.sd")$var.d

df$v_re1[[7]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[7,], denom = "pooled.sd")$var.d

df$v_re1[[8]] <- NA

df$v_re1[[9]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[9,], denom = "pooled.sd")$var.d

df$v_re1[[10]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[10,], denom = "pooled.sd")$var.d

df$v_re1[[11]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[11,], denom = "pooled.sd")$var.d

df$v_re1[[12]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[12,], denom = "pooled.sd")$var.d

df$v_re1[[13]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[13,], denom = "pooled.sd")$var.d

df$v_re1[[14]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[14,], denom = "pooled.sd")$var.d

df$v_re1[[15]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[15,], denom = "pooled.sd")$var.d

df$v_re1[[16]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[16,], denom = "pooled.sd")$var.d

df$v_re1[[17]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[17,], denom = "pooled.sd")$var.d

df$v_re1[[18]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[18,], denom = "pooled.sd")$var.d

df$v_re1[[19]] <- p_to_d1(df$p_ps[[19]], df$n_ps[[19]], df$n_ps[[19]])[2]

df$v_re1[[20]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[20,], denom = "pooled.sd")$var.d

# make numeric
df$v_re1 <- df$v_re1 %>% as.numeric()

# relocate to check if everything's fine
df$v_ma <- df$se_ma^2

df <- df %>% relocate(c(id_comparison, v_re1, v_ma), .after = dv_ps)
```

### Reproduce variances of the primary SMDs for MA model 2
```{r}
df$v_re2[[1]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[1,], denom = "pooled.sd")$var.d

df$v_re2[[2]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$var.d

df$v_re2[[3]] <- ((df$n_ps[[3]] + df$n_ps[[3]]) / (df$n_ps[[3]]*df$n_ps[[3]])) + (df$smd_ps[[3]]^2 / (2 * (df$n_ps[[3]] + df$n_ps[[3]])))

df$v_re2[[4]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[4,], denom = "pooled.sd")$var.d

df$v_re2[[5]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[5,], denom = "pooled.sd")$var.d

df$v_re2[[6]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[6,], denom = "pooled.sd")$var.d

df$v_re2[[7]] <- compute_ds(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[7,], denom = "pooled.sd")$var.d

df$v_re2[[8]] <- p_to_d2(df$p_ps[[8]], df$nc_ps[[8]], df$nt_ps[[8]])[2]

df$v_re2[[9]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[9,], denom = "pooled.sd")$var.d

df$v_re2[[10]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[10,], denom = "pooled.sd")$var.d

df$v_re2[[11]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[11,], denom = "pooled.sd")$var.d

df$v_re2[[12]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[12,], denom = "pooled.sd")$var.d

df$v_re2[[13]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[13,], denom = "pooled.sd")$var.d

df$v_re2[[14]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[14,], denom = "pooled.sd")$var.d

df$v_re2[[15]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[15,], denom = "pooled.sd")$var.d

df$v_re2[[16]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[16,], denom = "pooled.sd")$var.d

df$v_re2[[17]] <- compute_ds(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[17,], denom = "pooled.sd")$var.d

df$v_re2[[18]] <- compute_ds(n_ps, mt_ps.1, sdt_ps.1, n_ps, mc_ps.1, sdc_ps.1, data = df[18,], denom = "pooled.sd")$var.d

df$v_re2[[19]] <- p_to_d1(df$p_ps[[19]], df$n_ps[[19]], df$n_ps[[19]])[2]

df$v_re2[[20]] <- compute_ds(n_ps, mt_ps.2, sdt_ps.2, n_ps, mc_ps.2, sdc_ps.2, data = df[20,], denom = "pooled.sd")$var.d

# make numeric
df$v_re2 <- df$v_re2 %>% as.numeric()
```

### Reproduce the pooled SMD
#### MA model 1
```{r}
ma1 <- metagen(TE = smd_re1,
              seTE = sqrt(v_re1),
              studlab = id_comparison,
              data = df,
              sm = "SMD",
              fixed = FALSE,
              random = TRUE, # a random effects MA
              method.tau = "DL", # DerSimonian-Laird estimator
                 )
windowsFonts(A = windowsFont("Times New Roman"))

png("figures/fig4_mam1.png", units = "in", width = 7.2, height = 6, res = 300)
forest.meta(ma1,
           fontfamily = "A",
           print.tau2 = TRUE,
           leftlabs = c("SMD No.", "d", "SE"))
```

#### MA model 2
```{r}
ma2 <- metagen(TE = smd_re2,
              seTE = sqrt(v_re2),
              studlab = id_comparison,
              data = df,
              sm = "SMD",
              fixed = FALSE,
              random = TRUE, # a random effects MA
              method.tau = "DL", # DerSimonian-Laird estimator
                 )
png("figures/fig4_mam2.png", units = "in", width = 7.2, height = 6, res = 300)
forest.meta(ma2,
           fontfamily = "A",
           print.tau2 = TRUE,
           leftlabs = c("SMD No.", "d", "SE"))
```

#### MA model 3
```{r}
ma3 <- metagen(TE = smd_ma,
              seTE = se_ma,
              studlab = id_comparison,
              data = df,
              sm = "SMD",
              fixed = FALSE,
              random = TRUE, # a random effects MA
              method.tau = "DL", # DerSimonian-Laird estimator
                 )
png("figures/fig4_mam3.png", units = "in", width = 7.2, height = 6, res = 300)
forest.meta(ma3,
           fontfamily = "A",
           print.tau2 = TRUE,
           leftlabs = c("SMD No.", "d", "SE"))
```


## Publication bias analysis

### PET-PEESE
#### Collate the necessary variables
For the PET-PEESE model, the effect sizes (here SMDs), their SEs, their variances, and their inverse-variance weights, are needed.
```{r}
petpeese <- data.frame(smd = df$smd_ma) # smds
petpeese$v <- df$se_ma^2 # sampling variances (extracted from the figures)
petpeese$se <- df$se_ma # standard errors of SMD estimates
petpeese$w <- 1/petpeese$v # inverse variance weights
```

#### PET (precision-effect test)
```{r}
pet <- lm(smd ~ se, weights = w, data = petpeese)
summary(pet)$coefficients
```

#### PEESE (precision-effect estimate with standard error)
```{r}
peese <- lm(smd ~ v, weights = w, data = petpeese)
summary(peese)$coefficients
```


### P-Curve

#### P-Curve
```{r}
pcurve(ma3, 
       effect.estimation = TRUE,
       N = df$nt_ma + df$nc_ma, 
       dmin = 0,
       dmax = 1)
```



### Three-parameter selection model
#### Create a `metafor` package meta-analysis object, necessary for the `selmodel` function
```{r}
ma3_metafor <- rma(yi = smd_ma,        
          sei = se_ma,
          data = df,
          method = "DL")
```

#### Fit the selection model
```{r}
selmodel(ma3_metafor,
         type = "stepfun",
         steps = 0.025)
```



## Outlier/influence diagnostics
### Leave-one-out analysis
```{r}
metainf(ma3, pooled = "random")
```


### Some plots
#### Baujat 
```{r}
outl <- InfluenceAnalysis(ma3, random = TRUE, text.scale = 2)
png("figures/fig7.png", units = "in", width = 5, height = 5, res = 300)
plot(outl, "baujat")
```

#### Forest plot
```{r}
plot(outl, "ES")
```
### Run meta-analysis without outliers
```{r}
s <- update.meta(ma1, subset = -c(8, 9, 11, 19))
forest.meta(s,

            print.tau2 = TRUE,
            leftlabs = c("SMD No.", "d", "SE"))
```

# Meta-analysis 3

## Reproducibility

### Load dataset & preprocess data
```{r}
df <- read_excel("data_thesis/Data_ps_raw.xlsx", sheet = "MA3")

# make values numeric
df <- df %>% mutate_at(vars(starts_with('sd')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('mt')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('mc')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('smd')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('n')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('ci')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('p_')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('t_')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('F_')), as.numeric)
df <- df %>% mutate_at(vars(starts_with('si')), as.numeric)
```

```{r}
# average group sample size
mean((df$nc_ma + df$nt_ma) / 2, na.rm = TRUE)
```

### Reproduce primary SMDs
This MA only included RCTs. 1 out of the 6 studies included was a conference abstract which only reported the total sample size. The 5 others reported group sample sizes, 3 reported raw means and SDs, one reported a potentially usable $t$-value. Hedges' $g$ was used. 
#### Studies which reported means and SDs
```{r}
df <- compute_dgs(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df, denom = "pooled.sd")

# relocate to facilitate inspection
df <- df %>% relocate(c(id_comparison, g, smd_ma), .after = dv_ps)
```
SMD 4 was reproduced. SMD 2 was approximated but in the other direction. SMD 5 quite close. Data extraction will be double-checked.

#### Studies which did not report means and/or SDs
```{r}
t_to_d(df$t_ps[[6]], df$nt_ps[[6]], df$nc_ps[[6]])[1]
```
Nope.





### Reproduce primary SMDs -- post double-checking data-extraction for irreproducible SMDs
1. 
```{r}
df$d <- p_to_d2(0.01, df$nt_ps[[1]], df$nc_ps[[1]])[1]
df$vd <- p_to_d2(0.01, df$nt_ps[[1]], df$nc_ps[[1]])[2]
compute_gs(d, vd, nt_ps, nc_ps, df)$g[1]
```

2. 
```{r}
compute_dgs(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$g
```
```{r}
compute_dgs(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[2,], denom = "pooled.sd")$g
```

```{r}
df$mt_ps.3 <- (df$mt_ps.1 + df$mt_ps.2) / 2
df$sdt_ps.3 <- (df$sdt_ps.1 + df$sdt_ps.2) / 2

compute_dgs(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$g
```

```{r}
df$mt_ps.3[[2]] <- (df$mt_ps.1[[2]] + df$mt_ps.2[[2]]) / 2
df$sdt_ps.3[[2]] <- (df$sdt_ps.1[[2]] + df$sdt_ps.2[[2]]) / 2

compute_dgs(nt_ps*2, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$g
```

```{r}
compute_dgs(nt_ps*2, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$g
```

```{r}
compute_dgs(nt_ps*2, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[2,], denom = "pooled.sd")$g
```

3.
```{r}
df$d <- p_to_d2(0.01, df$n_ps[[3]], df$n_ps[[3]])[1]
df$vd <- p_to_d2(0.01, df$n_ps[[3]], df$n_ps[[3]])[2]
compute_gs(d, vd, n_ps, n_ps, df)$g[3]
```

5.based on second set
```{r}
compute_dgs(nt_ps, mt_ps.2, sdt_ps.2, nc_ps, mc_ps.2, sdc_ps.2, data = df[5,], denom = "pooled.sd")$g
```
nope

take average
```{r}
df$mc_ps.3 <- (df$mc_ps.1 + df$mc_ps.2) / 2
df$mt_ps.3 <- (df$mt_ps.1 + df$mt_ps.2) / 2
df$sdc_ps.3 <- (df$sdc_ps.1 + df$sdc_ps.2) / 2
df$sdt_ps.3 <- (df$sdt_ps.1 + df$sdt_ps.2) / 2
compute_dgs(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.3, sdc_ps.3, data = df[5,], denom = "pooled.sd")$g
```
yup

6.
```{r}
df$d <- p_to_d2(0.169, df$nc_ps[[6]], df$nt_ps[[6]])[1]
df$vd <- p_to_d2(0.169, df$nc_ps[[6]], df$nt_ps[[6]])[2]
compute_gs(d, vd, nt_ps, nc_ps, df)$g[6]
```
yup

Overview of the results of double-checking data extraction for each of the 20 primary SMDs:
1. SMD 1 could be reproduced using a $p$ value (given as a range <0.01) for the comparison between the control and treatment medians at post. It will be used for MMA2.----- 3
2. Best approximated by taking the first set of means and SDs (SMA) and doubling the sample size for the treatment group (USED FOR MMA2). It was negative because the variable is reaction times. The variation without doubling the sample size and by averaging the two sets will be used for MMA 1 since it corresponds to other reproducible SMDs. ----- 2, 3
3. Same as 1 -------- 3
4. reproducible based on means and SDs of change percentages from pre to post -------- 3
5. SMD 5 was approximated well by averaging sets 1 and 2 and computing the SMD based on the averaged values. ------ 1
6. SMD 6 could be reproduced using a $p$ value for the comparison between the control and treatment mean change from baseline. ----- 3


### Collate reproduced primary SMDs for MA model 1
```{r}
# 1
df$smd_re1[[1]] <- NA

# 2

df$mt_ps.3 <- (df$mt_ps.1 + df$mt_ps.2) / 2
df$sdt_ps.3 <- (df$sdt_ps.1 + df$sdt_ps.2) / 2
df$smd_re1[[2]] <- compute_dgs(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$g %>% abs()

# 3
df$smd_re1[[3]] <- NA

# 4
df$smd_re1[[4]] <- NA

#5 
df$mc_ps.3 <- (df$mc_ps.1 + df$mc_ps.2) / 2
df$mt_ps.3 <- (df$mt_ps.1 + df$mt_ps.2) / 2
df$sdc_ps.3 <- (df$sdc_ps.1 + df$sdc_ps.2) / 2
df$sdt_ps.3 <- (df$sdt_ps.1 + df$sdt_ps.2) / 2
df$smd_re1[[5]] <- compute_dgs(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.3, sdc_ps.3, data = df[5,], denom = "pooled.sd")$g

#6
df$smd_re1[[6]] <- NA

# make numeric
df <- df %>% mutate_at(vars(starts_with('smd')), as.numeric)

# relocate to facilitate inspection
df <- df %>% relocate(c(smd_re1, smd_ma, id_comparison),  .after = dv_ps)
```



### Collate reproduced primary SMDs for MA model 2
```{r}
# 1
df$d <- p_to_d2(df$p_ps[[1]], df$nt_ps[[1]], df$nc_ps[[1]])[1]
df$vd <- p_to_d2(df$p_ps[[1]], df$nt_ps[[1]], df$nc_ps[[1]])[2]
df$smd_re2[[1]] <- compute_gs(d, vd, nt_ps, nc_ps, df)$g[1]

# 2
df$smd_re2[[2]] <- compute_dgs(nt_ps*2, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$g %>% abs()

# 3
df$d <- p_to_d2(df$p_ps[[3]], df$n_ps[[3]], df$n_ps[[3]])[1]
df$vd <- p_to_d2(df$p_ps[[3]], df$n_ps[[3]], df$n_ps[[3]])[2]
df$smd_re2[[3]] <- compute_gs(d, vd, n_ps, n_ps, df)$g[3]

# 4
df$smd_re2[[4]] <- compute_dgs(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[4,], denom = "pooled.sd")$g

#5 
df$mc_ps.3 <- (df$mc_ps.1 + df$mc_ps.2) / 2
df$mt_ps.3 <- (df$mt_ps.1 + df$mt_ps.2) / 2
df$sdc_ps.3 <- (df$sdc_ps.1 + df$sdc_ps.2) / 2
df$sdt_ps.3 <- (df$sdt_ps.1 + df$sdt_ps.2) / 2
df$smd_re2[[5]] <- compute_dgs(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.3, sdc_ps.3, data = df[5,], denom = "pooled.sd")$g

#6
df$d <- p_to_d2(df$p_ps[[6]], df$nc_ps[[6]], df$nt_ps[[6]])[1]
df$vd <- p_to_d2(df$p_ps[[6]], df$nc_ps[[6]], df$nt_ps[[6]])[2]
df$smd_re2[[6]] <- compute_gs(d, vd, nt_ps, nc_ps, df)$g[6]

# make numeric
df <- df %>% mutate_at(vars(starts_with('smd')), as.numeric)

# relocate to facilitate inspection
df <- df %>% relocate(smd_re2,  .after = smd_re1)
```


### Reproduce variances of the primary SMDs for MA model 1
```{r}
# 1
df$v_re1[[1]] <- NA

# 2
df$v_re1[[2]] <- compute_dgs(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$var.g

# 3
df$v_re1[[3]] <- NA

# 4
df$v_re1[[4]] <- NA

#5 
df$mc_ps.3 <- (df$mc_ps.1 + df$mc_ps.2) / 2
df$mt_ps.3 <- (df$mt_ps.1 + df$mt_ps.2) / 2
df$sdc_ps.3 <- (df$sdc_ps.1 + df$sdc_ps.2) / 2
df$sdt_ps.3 <- (df$sdt_ps.1 + df$sdt_ps.2) / 2
df$v_re1[[5]] <- compute_dgs(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.3, sdc_ps.3, data = df[5,], denom = "pooled.sd")$var.g

#6
df$v_re1[[6]] <- NA
```



### Reproduce variances of the primary SMDs for MA model 2
```{r}
# 1
df$d <- p_to_d2(0.01, df$nt_ps[[1]], df$nc_ps[[1]])[1]
df$vd <- p_to_d2(0.01, df$nt_ps[[1]], df$nc_ps[[1]])[2]
df$v_re2[[1]] <- compute_gs(d, vd, nt_ps, nc_ps, df)$var.g[1]

# 2
df$v_re2[[2]] <- compute_dgs(nt_ps*2, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[2,], denom = "pooled.sd")$var.g

# 3
df$d <- p_to_d2(0.01, df$n_ps[[3]], df$n_ps[[3]])[1]
df$vd <- p_to_d2(0.01, df$n_ps[[3]], df$n_ps[[3]])[2]
df$v_re2[[3]] <- compute_gs(d, vd, n_ps, n_ps, df)$var.g[3]

# 4
df$v_re2[[4]] <- compute_dgs(nt_ps, mt_ps.1, sdt_ps.1, nc_ps, mc_ps.1, sdc_ps.1, data = df[4,], denom = "pooled.sd")$var.g

#5 
df$mc_ps.3 <- (df$mc_ps.1 + df$mc_ps.2) / 2
df$mt_ps.3 <- (df$mt_ps.1 + df$mt_ps.2) / 2
df$sdc_ps.3 <- (df$sdc_ps.1 + df$sdc_ps.2) / 2
df$sdt_ps.3 <- (df$sdt_ps.1 + df$sdt_ps.2) / 2
df$v_re2[[5]] <- compute_dgs(nt_ps, mt_ps.3, sdt_ps.3, nc_ps, mc_ps.3, sdc_ps.3, data = df[5,], denom = "pooled.sd")$var.g

#6
df$d <- p_to_d2(0.169, df$nc_ps[[6]], df$nt_ps[[6]])[1]
df$vd <- p_to_d2(0.169, df$nc_ps[[6]], df$nt_ps[[6]])[2]
df$v_re2[[6]] <- compute_gs(d, vd, nt_ps, nc_ps, df)$var.g[6]

# make numeric
df <- df %>% mutate_at(vars(starts_with('v_')), as.numeric)
```


### Compute sampling variances and SEs based on the reported CIs

```{r}
df$v_ma <- ((df$ciu_ma - df$smd_ma) / 1.96)^2
df$se_ma <- ((df$ciu_ma - df$smd_ma) / 1.96)

# compare with reproduced variances
df <- df %>% relocate(c(v_re1, v_re2, v_ma), .after = smd_ma)
```


### Reproduce the pooled SMD
#### MA model 1
```{r}
ma1 <- metagen(TE = smd_re1,
              seTE = sqrt(v_re1),
              studlab = id_comparison,
              data = df,
              sm = "SMD",
              fixed = FALSE,
              random = TRUE, # a random effects MA
              method.tau = "DL", # DerSimonian-Laird estimator
                 )
windowsFonts(A = windowsFont("Times New Roman"))

png("figures/fig5_mam1.png", units = "in", width = 7.2, height = 3, res = 300)
forest.meta(ma1,
           fontfamily = "A",
           print.tau2 = TRUE,
           leftlabs = c("SMD No.", "g", "SE"))
```

#### MA model 2
```{r}
ma2 <- metagen(TE = smd_re2,
              seTE = sqrt(v_re2),
              studlab = id_comparison,
              data = df,
              sm = "SMD",
              fixed = FALSE,
              random = TRUE, # a random effects MA
              method.tau = "DL", # DerSimonian-Laird estimator
                 )
png("figures/fig5_mam2.png", units = "in", width = 7.2, height = 3, res = 300)
forest.meta(ma2,
           fontfamily = "A",
           print.tau2 = TRUE,
           leftlabs = c("SMD No.", "g", "SE"))
```

#### MA model 3
```{r}
ma3 <- metagen(TE = smd_ma,
              seTE = se_ma,
              studlab = as.character(id_comparison),
              data = df,
              sm = "SMD",
              fixed = FALSE,
              random = TRUE, # a random effects MA
              method.tau = "DL", # DerSimonian-Laird estimator
                 )
png("figures/fig5_mam3.png", units = "in", width = 7.2, height = 3, res = 300)
forest.meta(ma3,
           fontfamily = "A",
           print.tau2 = TRUE,
           leftlabs = c("SMD No.", "g", "SE"))
```

## Publication bias analysis

### PET-PEESE
#### Collate the necessary variables
For the PET-PEESE model, the effect sizes (here SMDs), their SEs, their variances, and their inverse-variance weights, are needed.
```{r}
petpeese <- data.frame(smd = df$smd_ma) # smds
petpeese$v <- df$v_ma # sampling variances (extracted from the figures)
petpeese$se <- df$se_ma # standard errors of SMD estimates
petpeese$w <- 1/petpeese$v # inverse variance weights
```

#### PET (precision-effect test)
```{r}
pet <- lm(smd ~ se, weights = w, data = petpeese)
summary(pet)$coefficients
```

#### PEESE (precision-effect estimate with standard error)
```{r}
peese <- lm(smd ~ v, weights = w, data = petpeese)
summary(peese)$coefficients
```


### P-Curve

#### P-Curve
```{r}
pcurve(ma3, 
       effect.estimation = TRUE,
       N = df$nt_ma + df$nc_ma, 
       dmin = 0,
       dmax = 1)
```



### Three-parameter selection model
#### Create a `metafor` package meta-analysis object, necessary for the `selmodel` function
```{r}
ma3_metafor <- rma(yi = smd_ma,        
          sei = se_ma,
          data = df,
          method = "DL")
```

#### Fit the selection model
```{r}
selmodel(ma3_metafor,
         type = "stepfun",
         steps = 0.025)
```



## Outlier/influence diagnostics
### Leave-one-out analysis
```{r}
metainf(ma3, pooled = "random")
```


### Some plots
#### Baujat 
```{r}
outl <- InfluenceAnalysis(ma3, random = TRUE, text.scale = 2)
png("figures/fig8.png", units = "in", width = 5, height = 5, res = 300)
plot(outl, "baujat")
```

#### Forest plot
```{r}
plot(outl, "ES")
```

### Run meta-analysis without outliers
```{r}
s <- update.meta(ma3, subset = -c(2))
forest.meta(s,

            print.tau2 = TRUE,
            leftlabs = c("SMD No.", "g", "SE"))
```
